<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FPGA学习3：初识Verilog语法</title>
    <link href="/2022/07/04/12FPGA%E5%AD%A6%E4%B9%A03%EF%BC%9A%E5%88%9D%E8%AF%86Verilog%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/07/04/12FPGA%E5%AD%A6%E4%B9%A03%EF%BC%9A%E5%88%9D%E8%AF%86Verilog%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 一、Verilog HDL简介<ol><li>Verilog HDL是一种硬件描述语言，以文本的形式描述硬件结构和行为。可以表示逻辑电路图、逻辑表达式。</li><li>Verilog HDL语言与VHDL相比，代码简介、易学易用，发展较快。</li><li>由C语言发展而来，有一定相似性，但编程思想不同。</li></ol><h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1-逻辑值"><a href="#1-逻辑值" class="headerlink" title="1.逻辑值"></a>1.逻辑值</h3><p>0：逻辑低电平，条件为假<br>1：逻辑高电平，条件为真<br>Z：高阻态，无驱动<br>X：未知逻辑电平</p><h3 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h3><h4 id="1-模块的开始与结束"><a href="#1-模块的开始与结束" class="headerlink" title="1.模块的开始与结束"></a>1.模块的开始与结束</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899401789-6e978b98-a038-45fb-8119-394b99cbea73.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=12&id=ufd61ee01&margin=%5Bobject%20Object%5D&name=image.png&originHeight=16&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10116&status=done&style=none&taskId=ued05168e-7e1c-495a-bcdf-a8d82a43b49&title=&width=268.95238095238096" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899412529-52002758-f9e3-4be9-ab6b-0c55d845a84b.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=12&id=u4a30140d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=16&originWidth=98&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2441&status=done&style=none&taskId=u754731fb-9f1a-40a3-b11d-081c809b582&title=&width=74.66666666666667" alt="image.png"></p><p>模块名与.v文件的文件名应该保持一致</p><h4 id="2-输入输出信号"><a href="#2-输入输出信号" class="headerlink" title="2.输入输出信号"></a>2.输入输出信号</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899488111-944dfeec-e457-4de6-a8da-743c1b041f24.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=69&id=u488dee3d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=528&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34576&status=done&style=none&taskId=u6002af11-f1e4-4d4a-a487-2234f36fdf3&title=&width=402.2857142857143" alt="image.png"></p><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899521244-0feb2cdd-a7eb-4724-b1e9-b3208b49a9a6.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=68&id=uacd1fd13&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=256&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17420&status=done&style=none&taskId=ua711e73e-4cfc-42af-8bfe-f0b51c5d836&title=&width=181.04762268066406" alt="image.png"></p><p>wire映射为一跳物理练习<br>reg映射为一个物理寄存器</p><h4 id="4-参数"><a href="#4-参数" class="headerlink" title="4.参数"></a>4.参数</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899576451-4f00073c-afcc-4613-ae27-2733729d0a1d.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=46&id=ue5693a04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=61&originWidth=250&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13590&status=done&style=none&taskId=u5ff89d25-7fa9-4797-92cf-503329c8158&title=&width=190.47619047619048" alt="image.png"></p><p>localparam只能在模块内部使用，不用用于实例化</p><h4 id="5-常量"><a href="#5-常量" class="headerlink" title="5.常量"></a>5.常量</h4><p><strong>使用的是基数表示法</strong><br><strong>格式：</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899665926-713687cb-089e-4dbb-bdee-4b9806bb52cd.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=0.9907&crop=1&from=paste&height=16&id=uc60067c5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=21&originWidth=709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25039&status=done&style=none&taskId=ucffa71a6-2f51-40d6-b49a-5a044c85273&title=&width=535" alt="image.png"><br><strong>举例：</strong><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899739616-715e656b-12b0-420d-95c1-f7778f460411.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=38&id=u47133525&margin=%5Bobject%20Object%5D&name=image.png&originHeight=50&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32271&status=done&style=none&taskId=u88502ba5-5643-4e45-86d7-9532fd3b92b&title=&width=409.9047619047619" alt="image.png"><br><strong>注意：</strong> 二进制比较特殊<img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656899875579-1f429f03-2bbe-4604-a662-28a33f736c23.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=66&id=u7eaea8c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=87&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103152&status=done&style=none&taskId=uce4002b4-41d4-4228-9d0f-93cb5dd4b3c&title=&width=588.1904761904761" alt="image.png"></p><h4 id="6-赋值方式"><a href="#6-赋值方式" class="headerlink" title="6.赋值方式"></a>6.赋值方式</h4><p>阻塞赋值顺序执行</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656900003668-de9b2d22-b10e-4feb-af77-c82efb8afbda.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=143&id=uc2597d20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=150&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17968&status=done&style=none&taskId=u0895a8f8-02f0-41fa-bc1b-bb35303016b&title=&width=114.28571428571429" alt="image.png"></p><p>非阻塞赋值语句并行执行</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656900066575-1448cb43-4c7f-4647-8b5b-1c0e6554df34.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=144&id=u40428626&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=184&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19613&status=done&style=none&taskId=uae1045e2-80dd-432b-86f0-f59de0bb810&title=&width=140.1904761904762" alt="image.png"></p><h4 id="7-always语句"><a href="#7-always语句" class="headerlink" title="7.always语句"></a>7.always语句</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656900176178-bcc4514d-cc8e-4088-835d-22091d57935d.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=104&id=u14443f1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=137&originWidth=406&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36287&status=done&style=none&taskId=u3400e95a-5ad7-4494-bdaf-e1cbea6891d&title=&width=309.3333333333333" alt="image.png"></p><h4 id="8-assign语句"><a href="#8-assign语句" class="headerlink" title="8.assign语句"></a>8.assign语句</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656900232767-ac838b71-ac50-4e64-9bbb-e4a50e7d7068.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=33&id=u4d94ea35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=43&originWidth=445&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13235&status=done&style=none&taskId=u81c9bcec-3630-45c9-a69d-85f1b93bba8&title=&width=339.04761904761904" alt="image.png"></p><h3 id="3-算数运算符"><a href="#3-算数运算符" class="headerlink" title="3.算数运算符"></a>3.算数运算符</h3><p>+（加法，如assignc＝a＋b；即把a与b的和赋值给c） </p><p>-（减法，如assignc＝a-b；即把a减b的差赋值给c）</p><p>*（乘法，如assignc＝a＊3；即让a和3相乘，结果赋值给c，但是一般不用乘号）</p><p>&#x2F;（除法，如assignc＝a／2；即让a和2相除，结果赋值给c，一般也不用除号）</p><p>%（求模，或称为求余，要求％两侧均为整型数据，5％3的值为2，用在测试文件）</p><h3 id="3-规约运算符、按位运算符"><a href="#3-规约运算符、按位运算符" class="headerlink" title="3.规约运算符、按位运算符"></a>3.规约运算符、按位运算符</h3><p>以“＆”操作符为例，“＆”操作符有两种用途，既可以作为<strong>一元运算符</strong>（仅有一个参与运算的量），也可以作为<strong>二元运算符</strong>（有两个参与运算的量）。</p><ul><li>作为一维运算符</li></ul><p>当“＆”作为一元运算符时表示归约与，＆m是将m中所有比特相与，最后的结果为1bit。</p><p>例如：<br>&amp;4’b1111&#x3D;1&amp;1&amp;1&amp;1&#x3D;1’b1<br>&amp;4’b1101&#x3D;1&amp;1&amp;0&amp;1&#x3D;1’b0</p><ul><li>作为二维运算符</li></ul><p>当“＆”作为二元运算符时表示按位与，m＆n是将m的每个比特与n的相应比特相与，在运算的时候要保证m和n的比特数相等，最后的结果和m（n）的比特数相同。</p><p>例如：   4’b1010&amp;4’b0101&#x3D;4’b0000 4’b1101&amp;4’b1111&#x3D;4’b1101<br>“～＆”、“A”、“～A”、“｜”、“～｜”同理。</p><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><p>以“&amp;&amp;”操作符为例，“&amp;&amp;”表示逻辑与，运算规则：逻辑与运算符号两边只有真或者假，非零表示真，零表示假，逻辑运算符两边都不为零则结果为1，否则为0。</p><p>例如： a＝4’ha，b＝4’d0，c＝a&amp;&amp;b，则c的值为0，<br>“||（逻辑或）”、“&#x3D;&#x3D;（逻辑相等）”、“!&#x3D;（逻辑不等）” 同理。</p><h3 id="5-关系运算符"><a href="#5-关系运算符" class="headerlink" title="5.关系运算符"></a>5.关系运算符</h3><p>a&lt;ba小于b </p><p>a&gt;ba大于b</p><p>a&lt;&#x3D;ba小于或等于b </p><p>a&gt;&#x3D;ba大于或等于b</p><p>注：关系运算符一般在条件判断时用到，例如if的判断语句，如果 if后面接的判断语句为真，则返回1，否则返回0</p><h3 id="6-移位运算符"><a href="#6-移位运算符" class="headerlink" title="6.移位运算符"></a>6.移位运算符</h3><p>移位运算符是二元运算符，左移符号为“&lt;&lt;”，右移符号为“&gt;&gt;”，将运算符左边的操作数左移或右移指定的位数，用0来补充空闲位。</p><p>b &lt;&#x3D;a&lt;&lt;1；即让a的每一位都往左移动1位，结果赋值给b；   (&lt;&#x3D;这是赋值的符号)</p><p>b &lt;&#x3D;a&gt;&gt;2；即让a的每一位都往右移动2位，结果赋值给b；<br>在应用移位运算符的时候一定要注意它的这个特性，那就是空闲位用0来填充，也就是说，一个二进制数不管原数值是多少，只要一直移位，最终全部会变为0。</p><p>例如：4＇b1000&gt;&gt;3后的结果为4＇b0001，4＇b1000 &gt;&gt;4的结果为4＇b0000。</p><p>移位运算符在使用时，可代替乘法和除法，左移一位可以看成是乘以2，右移一位可以看成是除以2，但要注意位宽的拓展。</p><h3 id="7-位拼接运算符"><a href="#7-位拼接运算符" class="headerlink" title="7.位拼接运算符"></a>7.位拼接运算符</h3><p>位拼接运算符由一对花括号加逗号组成“｛ , }”，拼接的不同数据之问用“，”隔开。</p><p>例如：<br>将8bit的a、3bit的b、5bit的按顺序拼接成一个16位的d，表示方法为：d＝｛a，b，c｝；</p><h3 id="8-条件运算符"><a href="#8-条件运算符" class="headerlink" title="8.条件运算符"></a>8.条件运算符</h3><p>条件运算符，“？：”，是一个三元运算符，即有三个参与运算的量，条件表达式的一 般形式为：表达式1？表达式2：表达式3<br>执行过程是：当表达式1为真，则表达式2作为条件表达式的值，否则以表达式3作为条件表达式的值。</p><p>例如：当a＝6，b＝7，c＝（a＞b）？a：b的结果为7。</p><p><strong>注意：</strong> 使用条件表达式时“？”和“：”是一对，不可以只是用一个； </p><h3 id="9-优先级"><a href="#9-优先级" class="headerlink" title="9.优先级"></a>9.优先级</h3><p>总的优先级关系为：归约运算符＞算数运算符＞移位运算符＞关系运算符＞“&#x3D;&#x3D;”和“！&#x3D;”＞按位运算符＞“＆＆”和“Il”＞条件运算符，总的来说是一元运算符＞一元运算符＞三元运算符。</p><p>如果在编写代码的时候对这些关系容易混淆，最好的方式就是使用“（）”增加优先级。</p><h3 id="10-if-else语句"><a href="#10-if-else语句" class="headerlink" title="10.if-else语句"></a>10.if-else语句</h3><p>if—else 条件分支语句的作用是根据指定的判断条件是否满足来确定下一步要执行的操作。它在使用时可以采用如下三种形式：</p><h4 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（＜条件表达式＞）<br>      语句或语句块;<br></code></pre></td></tr></table></figure><p>在if—else 条件语句的这种使用形式中没有出现 else项，这种情况下条件分支语句的执行过程是：如果指定的＜条件表达式＞成立（也就是这个条件表达式的逻辑值为“1”），则执行条件分支语句内给出的“语句或语句块”，然后退出条件分支语句的执行；如果＜条件表达式＞不成立（也就是条件的表达式的逻辑值为“0”、“x”、“z”），则不执行条件分支语句内给出的“语句或语句块”，而是直接退出条件语句的执行。这种写法如果在always块中表达级合逻辑时会产生latch，所以不推荐这种写法。</p><h4 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（＜条件表达式<span class="hljs-number">1</span>＞）<br>    语句或语句块<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（＜条件表达式<span class="hljs-number">2</span>＞） <br>    语句或语句块<span class="hljs-number">2</span>：<br>......<br><span class="hljs-keyword">else</span><br></code></pre></td></tr></table></figure><p>在执行这种形式的 if—else条件分支语句时，将按照各分支项的排列顺序对各个条件表达式是否成立做出判断，当遇到某一项的条件表达式成立时，就执行这一项所指定的语句或语句块：如果所有的条件表达式都不成立，则执行最后的 else项。这种形式的 if—else 条件分支语句实现了一种多路分支选择控制。这种写法是我们在使用根据波形写代码的方法中最常用的一种写法。</p><h4 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h4><p>（3）Verilog HDL 允许 if—else 条件分支语句的嵌套使用，但是不要嵌套太多层，也不推荐这<br>种嵌套的写法，因为嵌套会有优先级的问题，最后导致逻辑混乱，if和else的结合混乱，代码也不清晰，如果写代码时遇到这种情况往往是可以将其合并的，最终写成（2）的形式。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（＜条件表达式<span class="hljs-number">1</span>＞）  <span class="hljs-comment">//外层1L语句 </span><br>  <span class="hljs-keyword">if</span>（＜条件表达式<span class="hljs-number">2</span>＞） <span class="hljs-comment">//内层if语句1 </span><br>    语句或语句块<span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span>        <span class="hljs-comment">//内层else语句2</span><br>     语句或语句块<span class="hljs-number">2</span>；<br><span class="hljs-keyword">else</span>        <span class="hljs-comment">//外层else语句1</span><br>     语句或语句块<span class="hljs-number">3</span>；<br></code></pre></td></tr></table></figure><h3 id="11-case分支语句"><a href="#11-case分支语句" class="headerlink" title="11.case分支语句"></a>11.case分支语句</h3><p>case 分支语句是另一种用来实现多路分支控制的分支语句。与使用 if—else条件分支语句相比，采用case分支语句来实现多路控制将显得更为方便与直观。case 分支语句通常用于对微处理器指令译码功能的描述以及对<strong>有限状态机</strong>的描述。case 分支语句有“case”、“casez”、“casex”三种形式。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">case</span>（＜控制表达式＞）<br>    ＜分支语句<span class="hljs-number">1</span>＞:语句块<span class="hljs-number">1</span>;<br>    ＜分支语句<span class="hljs-number">2</span>＞:语句块<span class="hljs-number">2</span>;<br>    ＜分支语句<span class="hljs-number">3</span>＞:语句块<span class="hljs-number">3</span>;<br>    ＜分支语句n＞:语句块n;<br>    <span class="hljs-keyword">default</span>:语句块n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure><p>＜控制表达式＞代表着对程序流向进行控制的控制信号：各个＜分支表达式＞则是控制表达式的某些具体状态取值，在实际使用中这些分支项表达式通常是一些常量表达式：各个“语句”则指定了在各个分支下所要执行的操作，它们也可以是由单条语句构成，处于最后的、以关键词 default 开头的那个分支项称为“default”分支项，它是可以缺省的。</p><p>case 语句的执行过程：</p><p>(1)当“控制表达式”的取值等于“分支项表达式1”时，执行第一个分支项所包含的语句块1；</p><p>(2)当“控制表达式”的取值等于“分支项表达式2”时，执行第二个分支项所包含的语句块2;</p><p>(3)当“控制表达式”的取值等于“分支项表达式n”时，执行第N个分支项所包含的语句块n；</p><p>(4)在执行了某一分支项内的语句后，跳出 case 语句结构，终止 case 语句的执行。case 语句中各个“分支项表达式”的取值必须是互不相同的，否则就会出现矛盾现象。</p><h3 id="12-系统函数"><a href="#12-系统函数" class="headerlink" title="12.系统函数"></a>12.系统函数</h3><p>Verilog 语言中预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数，这些函数大多数都是只能在Testbench 仿真中使用的，使我们更方便的进行验证。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ns </span><span class="hljs-comment">//时间尺度预编译指令 时间单位／时间精度</span><br></code></pre></td></tr></table></figure><p>时间单位和时间精度由值1、10、和100以及单位s、ms、us、ns、ps和fs组成。</p><p>时间单位：定义仿真过程所有与时间相关量的单位。</p><p>仿真中使用“＃数字”表示延时相应时间单位的时间，例＃10表示延时10个单位的时间，即10ns。</p><p>时间精度：决定时间相关量的精度及仿真显示的最小刻度。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">`timescalo <span class="hljs-number">1</span>ns/<span class="hljs-number">10</span>ps 精度<span class="hljs-number">0</span><span class="hljs-variable">.01</span>，＃<span class="hljs-number">10</span><span class="hljs-variable">.11</span> 表示延时<span class="hljs-number">10110</span>ps 下面这种写法就是错误的，因为时间单位不能比时间精度小。<br><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 100ps/1ns</span><br></code></pre></td></tr></table></figure><p>主要的函数有如下这些，在支持 Verilog 语法的编辑器中都会显示为高亮关键字</p><table><thead><tr><th>$display</th><th>&#x2F;&#x2F;打印信息,自动换行</th></tr></thead><tbody><tr><td>$write</td><td>&#x2F;&#x2F;打印信息</td></tr><tr><td>$strobe</td><td>&#x2F;&#x2F;打印信息,自动换行,最后执行</td></tr><tr><td>$monitor</td><td>&#x2F;&#x2F;监测变量</td></tr><tr><td>$stop</td><td>&#x2F;&#x2F;暂停仿真</td></tr><tr><td>$finish</td><td>&#x2F;&#x2F;结束仿真</td></tr><tr><td>$time</td><td>&#x2F;&#x2F;时间函数</td></tr><tr><td>$random</td><td>&#x2F;&#x2F;随机函数</td></tr><tr><td>$readmemb</td><td>&#x2F;&#x2F;读文件函数</td></tr></tbody></table><h4 id="1-display用于输出、打印信息"><a href="#1-display用于输出、打印信息" class="headerlink" title="1.$display用于输出、打印信息"></a>1.$display用于输出、打印信息</h4><p>使用格式为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%b＋%b＝%d&quot;</span>,a,b,c); <span class="hljs-comment">//格式“％b＋％b＝％d”格式控制，未指定时默认十进制 </span><br>%h或%H<span class="hljs-comment">//以十六进制的形式输出</span><br>%d或%D<span class="hljs-comment">//以十进制的形式输出</span><br>%o或%O<span class="hljs-comment">//以八进制的形式输出</span><br>%b或%B<span class="hljs-comment">//以二进制的形式输出</span><br></code></pre></td></tr></table></figure><p>实例展示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656902444944-ee4367e3-82a6-4250-bb5b-05043ad6d992.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=uac9fe979&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52481&status=done&style=none&taskId=uccb90862-3345-46f4-926d-d795682aeba&title=&width=243.8095238095238" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903331436-912eaa21-f409-40a2-81de-980a9aab8dba.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=169&id=u156951df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43639&status=done&style=none&taskId=ue80e9a50-056b-4e66-9abb-6a5a4f03ac5&title=&width=345.9047619047619" alt="image.png"></p><h4 id="2-write-用于输出、打印信息（不会自动换行）"><a href="#2-write-用于输出、打印信息（不会自动换行）" class="headerlink" title="2.$write 用于输出、打印信息（不会自动换行）"></a>2.$write 用于输出、打印信息（不会自动换行）</h4><p>使用格式为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$write</span>(<span class="hljs-string">&quot;%b＋%b＝%d\n&quot;</span>,a, b,c);  <span class="hljs-comment">//“％b＋％b＝％d”格式控制，未指定时默认十进制 </span><br>\n   <span class="hljs-comment">//表示换行</span><br></code></pre></td></tr></table></figure><h4 id="3-strobe用于输出、打印信息"><a href="#3-strobe用于输出、打印信息" class="headerlink" title="3.$strobe用于输出、打印信息"></a>3.$strobe用于输出、打印信息</h4><p>与前面两个的区别是只在最后执行</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903343174-a93ded6c-a0df-4f7b-b23a-963b41e8742e.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=115&id=ufe573d16&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39337&status=done&style=none&taskId=u78cc79e5-6290-4740-b574-b98d051df36&title=&width=339.8095238095238" alt="image.png"></p><p>输出结果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903347947-e369935f-adf5-472a-a07e-7ec1f4d12664.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=146&id=u7d9d9dc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=191&originWidth=450&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45044&status=done&style=none&taskId=ud9c5c552-7f96-47bc-9e8f-af2e3b820d1&title=&width=342.85714285714283" alt="image.png"></p><h4 id="4-monitor用于持续监测变量"><a href="#4-monitor用于持续监测变量" class="headerlink" title="4.$monitor用于持续监测变量"></a>4.$monitor用于持续监测变量</h4><p>变量每被赋值一次都进行一次打印<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903064684-5cf8dbe9-236b-4f32-8cf9-f6ce5abd924c.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=u6818a385&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23798&status=done&style=none&taskId=ud96ffe22-d38a-431f-bdd8-de9090335e9&title=&width=283.42857142857144" alt="image.png"></p><p>输出结果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903056130-50ed0a2c-743e-4109-9fa1-538c418abdc5.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=u6d8c88d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=486&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48017&status=done&style=none&taskId=uf2346dc0-4b9a-4413-947a-ea082f47968&title=&width=288.28570556640625" alt="image.png"></p><h4 id="5-stop用于暂停仿真，-finish用于结束仿真"><a href="#5-stop用于暂停仿真，-finish用于结束仿真" class="headerlink" title="5.$stop用于暂停仿真，$finish用于结束仿真"></a>5.$stop用于暂停仿真，$finish用于结束仿真</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656902993652-b1b2e169-9fda-4f72-b6e2-e38a57fdbc1a.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=211&id=ua8040f35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=385&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69178&status=done&style=none&taskId=u197b7300-bc15-491b-bba5-0f14073935d&title=&width=293.3333333333333" alt="image.png"></p><p>代码中的#100 是等待100个时间单位</p><p>输出结果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903168154-3d98624d-2c90-4546-8ed7-ddffa4f0a4c0.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=204&id=ub93055cf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=460&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84133&status=done&style=none&taskId=uc57be408-0903-4744-ba82-4e7b23e96db&title=&width=350.4761904761905" alt="image.png"></p><h4 id="6-time为时间函数，返回64位当前仿真时间；-random用于产生随机函数，返回随机数"><a href="#6-time为时间函数，返回64位当前仿真时间；-random用于产生随机函数，返回随机数" class="headerlink" title="6. $time为时间函数，返回64位当前仿真时间；$random用于产生随机函数，返回随机数"></a>6. $time为时间函数，返回64位当前仿真时间；$random用于产生随机函数，返回随机数</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903141222-52606dc4-3687-48cf-a608-821a58a590a4.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=123&id=uf7d80974&margin=%5Bobject%20Object%5D&name=image.png&originHeight=161&originWidth=407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30175&status=done&style=none&taskId=ud713c80b-ee8e-431d-bf6e-d8292616dee&title=&width=310.0952380952381" alt="image.png"></p><p>输出结果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903158607-6d76f4f1-d51d-4cd2-a3f2-b3565085af54.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=uf885032a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=449&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61585&status=done&style=none&taskId=ua4a3eafc-c0db-4946-b292-c35f77dffc0&title=&width=342.0952380952381" alt="image.png"></p><h4 id="7-readmemb用于读二进制文件函数，-readmemh-用于读十六进制文件函数"><a href="#7-readmemb用于读二进制文件函数，-readmemh-用于读十六进制文件函数" class="headerlink" title="7.$readmemb用于读二进制文件函数，$readmemh 用于读十六进制文件函数"></a>7.$readmemb用于读二进制文件函数，$readmemh 用于读十六进制文件函数</h4><p>使用格式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-built_in">$readmemb</span>（<span class="hljs-string">&quot;＜数据文件名＞&quot;</span>，＜存贮器名＞）;<br><span class="hljs-built_in">$readmemh</span>（<span class="hljs-string">&quot;＜数据文件名＞&quot;</span>，＜存贮器名＞）;<br></code></pre></td></tr></table></figure><p>实例：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903458563-7a985253-3eaf-48f1-883a-423047a2828d.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=211&id=u150c2480&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47907&status=done&style=none&taskId=u0a92128a-3b7f-4754-9873-b256b19e661&title=&width=247.61904761904762" alt="image.png"></p><p>输出结果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656903553160-672f5033-9636-4e87-a1df-ff3346264dfd.png#clientId=u93596d75-2520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u17346dcf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=217&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46511&status=done&style=none&taskId=u0a140422-34ce-4a89-ab66-43cf9479dd5&title=&width=343.6190476190476" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>FPGA学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试准备第三天-数据库复习2</title>
    <link href="/2022/07/03/11%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%B8%89%E5%A4%A9-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02/"/>
    <url>/2022/07/03/11%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%B8%89%E5%A4%A9-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />> 今天是面试准备的第三天，复习一下数据库概念性问题，参考资料来自up主：https://space.bilibili.com/949043<h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h2><h3 id="1、数据库的4个基本概念"><a href="#1、数据库的4个基本概念" class="headerlink" title="1、数据库的4个基本概念"></a>1、数据库的4个基本概念</h3><p>①数据data：描述事物的符号，数据库中存储的基本对象</p><p>②数据库DataBase, DB：长期存储在计算机内的、有组织的、可共享的大量数据的集合</p><p>③数据库管理系统DataBase Management System, DBMS：位于用户与操作系统之间的一层数据管理软件</p><p>④数据库系统DataBase System,DBS：由数据库、数据库管理系统、应用程序和数据库管理员（DBA）组成</p><h3 id="2、数据库系统的特点"><a href="#2、数据库系统的特点" class="headerlink" title="2、数据库系统的特点"></a>2、数据库系统的特点</h3><p>①数据结构化</p><p>②数据的共享性高，冗余度低而且容易扩充</p><p>③数据独立性高：物理独立性（应用程序与物理存储相互独立，数据的物理存储改变，应用程序不改变），逻辑独立性（应用程序与逻辑结构相互独立，数据的逻辑结构改变，应用程序不改变）</p><p>④数据由数据库管理系统统一管理和控制</p><h3 id="3、数据模型"><a href="#3、数据模型" class="headerlink" title="3、数据模型"></a>3、数据模型</h3><p>数据模型包括概念模型（信息模型）和逻辑模型模型</p><p>概念模型按用户的观点建模，用于数据库设计，表示方法有E—R模型</p><p>逻辑模型按计算机的观点建模，用于DBMS实现，包括网状模型、层次模型、关系模型等等物理模型是对数据最底层的抽象</p><h3 id="4、数据模型的组成要素：数据结构、数据操作、数据的完整性约束条件"><a href="#4、数据模型的组成要素：数据结构、数据操作、数据的完整性约束条件" class="headerlink" title="4、数据模型的组成要素：数据结构、数据操作、数据的完整性约束条件"></a><font color='red'>4、数据模型的组成要素：数据结构、数据操作、数据的完整性约束条件</font></h3><p>数据模型是严格定义的一组概念的集合，需要精确描述系统的静态特性、动态特性和完整性约束条件因此数据模型由以下三个部分组成：</p><p>①数据结构：描述系统的静态特性→描述数据库的组成对象以及对象之间的联系</p><p>②数据操作：描述系统的动态特性→是对数据库中各种对象的实例所允许的操作的集合，其类型有查询和更新（增删改）</p><p>③数据的完整性约束条件：用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效与相容，完整性约束条件是一组完整性规则的集合</p><h3 id="5、数据库系统的三级模式结构：外模式、模式（逻辑模式）、内模式应用"><a href="#5、数据库系统的三级模式结构：外模式、模式（逻辑模式）、内模式应用" class="headerlink" title="5、数据库系统的三级模式结构：外模式、模式（逻辑模式）、内模式应用"></a><font color='red'>5、数据库系统的三级模式结构：外模式、模式（逻辑模式）、内模式应用</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656856502643-47817fc7-fcb9-4814-a5c6-9e33cbe86eaa.png" alt="img"></p><p>①外模式（子模式&#x2F;用户模式）：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，数据库用户的数据视图，是与某应用有关的数据的逻辑表示</p><p>②模式（逻辑模式）：数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图③内模式（存储模式）：数据物理结构和存储方法的描述，是数据在数据库内部的组织方式</p><h3 id="6、数据库的二级映像功能与数据独立性"><a href="#6、数据库的二级映像功能与数据独立性" class="headerlink" title="6、数据库的二级映像功能与数据独立性"></a>6、数据库的二级映像功能与数据独立性</h3><p>①外模式&#x2F;模式映像：保证了数据的逻辑独立性</p><p>当模式改变时，对外模式&#x2F;模式的映像做出改变，保证外模式不变，应用程序由外模式编写，从而应用程序不变</p><p>②模式&#x2F;内模式映像：保证了数据的物理独立性</p><p>当数据库的存储结构改变时，对模式&#x2F;内模式映像做出改变，使模式不变，进而应用程序不变</p><h2 id="第四章：数据库安全性"><a href="#第四章：数据库安全性" class="headerlink" title="第四章：数据库安全性"></a>第四章：数据库安全性</h2><h3 id="1、不安全因素"><a href="#1、不安全因素" class="headerlink" title="1、不安全因素"></a>1、不安全因素</h3><p>①非授权用户对数据库的恶意存取和破坏②数据库中重要数据的泄露</p><p>③安全环境的脆弱性</p><h3 id="2、数据库安全性控制"><a href="#2、数据库安全性控制" class="headerlink" title="2、数据库安全性控制"></a>2、数据库安全性控制</h3><p>①用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别②存取控制</p><p>③自主存取控制方法</p><h3 id="3、为什么要授权"><a href="#3、为什么要授权" class="headerlink" title="3、为什么要授权"></a><font color='red'>3、为什么要授权</font></h3><p>授权是指授予（GRANT）和收回（REVOKE），是数据库安全性控制中的自主存取控制方法。是为了保护数据库，防止不合法使用所造成的数据泄露、更改或破坏</p><h3 id="4、如何授权：授予GRANT"><a href="#4、如何授权：授予GRANT" class="headerlink" title="4、如何授权：授予GRANT"></a>4、如何授权：授予GRANT</h3><p>发出如下语句的可以是数据库管理员、也可以是数据库对象创建者、也可以是已经拥有该权限的用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限 <span class="hljs-keyword">ON</span> 对象类型 对象名 <span class="hljs-keyword">TO</span> 用户名 [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]；<br></code></pre></td></tr></table></figure><p><strong>权限：</strong>查询权限 SELECT，全部操作权限 ALL PRIVILEGES</p><p><strong>对象类型&amp;对象名：</strong>对象类型可以是TABLE也可以是VIEW，对象名为对应的表名或者视图名</p><p><strong>用户名：</strong>可以是指定用户，也可以是全体用户PUBLIC</p><p>如果没有指定WITH GRANT OPTION 子句，则获得某种权限的用户只能使用该权限，不能传播该权限</p><p><strong>注意：</strong> SQL不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先</p><p>eg.把查询权限授给用户U1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">TO</span> U1;<br></code></pre></td></tr></table></figure><h3 id="5、收回授权：收回REVOKE"><a href="#5、收回授权：收回REVOKE" class="headerlink" title="5、收回授权：收回REVOKE"></a><font color='red'>5、收回授权：收回REVOKE</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限 <span class="hljs-keyword">ON</span> 对象类型 对象名<span class="hljs-keyword">FROM</span> 用户名 [CASCADEJRESTRICT];<br></code></pre></td></tr></table></figure><p>CASCADE：级联回收。将用户传播出去的权限一并收回</p><p>RESTRICT：受限回收。若用户传播过该权限，回收将会失败</p><p>eg.把用户U4修改学生学号的权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span>(Sno) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">FROM</span> U4;<br></code></pre></td></tr></table></figure><h3 id="6、创建数据库模式的权限"><a href="#6、创建数据库模式的权限" class="headerlink" title="6、创建数据库模式的权限"></a>6、创建数据库模式的权限</h3><p>对创建数据库模式一类的数据库对象的授权再数据库管理员创建用户时实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> username [<span class="hljs-keyword">WITH</span> DBAJRESOURCEICONNECT];<br></code></pre></td></tr></table></figure><p>只有系统的超级用户才有权创建一个新的数据库用户，新创建的数据库用户有三种权限：DBA、RESOURCE、CONNECT （此为默认）</p><p>DBA：可以创建新用户、创建模式、创建基本表和视图等，拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户</p><p>RESOURCE：可以创建基本表和视图，但不能创建模式和新用户。数据库对象的属主可以用GRANT 语句把该对象上的存取权限授予其他用户</p><p>CONNECT：只能登陆数据库，根据其他用户或者数据库管理员授予的权限的情况对数据库对象进行权限范围内的操作</p><h3 id="7、数据库角色"><a href="#7、数据库角色" class="headerlink" title="7、数据库角色"></a>7、数据库角色</h3><p>角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程</p><p><strong>创建角色：</strong>CREATE ROLE 角色名；</p><p><strong>在一个角色中添加角色或者用户：</strong> GRANT 角色TO 某角色&#x2F;某用户[WITH ADMIN OPTION]；</p><p>指定WITH ADMIN OPTION 子句，则获得某种权限的角色或者用户还可以把这种权限再授予其他角色</p><p><strong>给角色授权：</strong> GRANT 权限 ON 对象类型 对象名TO角色；</p><p><strong>角色权限收回：</strong>REVOKE 权限ON 对象类型 对象名FROM 角色；</p><h3 id="8、视图机制"><a href="#8、视图机制" class="headerlink" title="8、视图机制"></a>8、视图机制</h3><p>为不同的用户定义不同的视图，把不需要的数据隐藏，这样用户就不会误操作</p><h3 id="9、审计"><a href="#9、审计" class="headerlink" title="9、审计"></a>9、审计</h3><p>把对数据库的所有操作都记录到审计日志中，然后就可以通过日志审查这个里面是否有一些非法的行为</p><h3 id="10、数据加密"><a href="#10、数据加密" class="headerlink" title="10、数据加密"></a>10、数据加密</h3><p>通过一些加密算法，把明文变成密文。这样别人就无法查看</p><h2 id="第五章：数据库完整性"><a href="#第五章：数据库完整性" class="headerlink" title="第五章：数据库完整性"></a>第五章：数据库完整性</h2><h3 id="1、数据库的完整性是指数据的正确性和相容性"><a href="#1、数据库的完整性是指数据的正确性和相容性" class="headerlink" title="1、数据库的完整性是指数据的正确性和相容性"></a>1、数据库的完整性是指数据的正确性和相容性</h3><p>正确性：符合现实世界语义</p><p>相容性：同一对象在不同表中的数据符合逻辑</p><h3 id="2、维护完整性需要实现的功能"><a href="#2、维护完整性需要实现的功能" class="headerlink" title="2、维护完整性需要实现的功能"></a>2、维护完整性需要实现的功能</h3><p>①提供定义完整性约束条件的机制</p><p>②提供完整性检查的方法</p><p>③进行违约处理</p><h3 id="3、三大完整性"><a href="#3、三大完整性" class="headerlink" title="3、三大完整性"></a>3、三大完整性</h3><p>①实体完整性：主码唯一且非空</p><p>检查与违约处理：检查主码是否唯一，如果不唯一则拒绝插入或修改；检查主码各个属性是否为空，只要有一个为空就拒绝插入或修改</p><p>②参照完整性：外码的约束</p><p>检查：对被参照表和参照表进行增删改操作时可能会破坏参照完整性，必须检查以保证两个表的相容性</p><p>违约处理：外码约束可以在创建参照表时说明不同的违约策略</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656857058711-29c7572c-4aae-4196-95f3-befe70c77074.png" alt="img"></p><p>③用户定义完整性：属性上约束条件的定义</p><p>1.属性上的约束条件</p><p>非空NOT NULL列值唯—UNIQUE</p><p>检查列值是否满足一个表达式CHECK</p><p>检查和违约处理：当向表中插入元组或者修改属性值时，关系数据库管理系统将检查属性上的约束条件是否被满足，如果不满足则操作被拒绝</p><p>2.元组上的约束条件</p><p>在CREATE TABLE 语句中可以用 CHECK短语定义元组上的约束条件，元组级的限制可以设置不同属性之间的取值的相互约束条件</p><p>检查和违约处理：当向表中插入元组或者修改属性值时，关系数据库管理系统将检查元组上的约束条件是否被满足，如果不满足则操作被拒绝</p><h2 id="第七章：数据库设计的步骤"><a href="#第七章：数据库设计的步骤" class="headerlink" title="第七章：数据库设计的步骤"></a>第七章：数据库设计的步骤</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>调查机构情况与熟悉业务活动，明确用户的需求，确定系统的边界，生成数据字典和用户需求规格说明书</p><h3 id="2、概念结构设计"><a href="#2、概念结构设计" class="headerlink" title="2、概念结构设计"></a>2、概念结构设计</h3><p>将需求分析得到的用户需求抽象为概念模型，绘制E—R图</p><h3 id="3、逻辑结构设计"><a href="#3、逻辑结构设计" class="headerlink" title="3、逻辑结构设计"></a>3、逻辑结构设计</h3><p>将E—R图转换为与DBMS相符合的逻辑结构（包括数据库模式和外模式），例如E—R图向关系模型转换，再根据规范化理论对数据模型进行优化，设计用户子模式</p><h3 id="4、物理结构设计"><a href="#4、物理结构设计" class="headerlink" title="4、物理结构设计"></a>4、物理结构设计</h3><p>通常关系数据库物理设计的内容包括关系模式选择存取方法、以及设计关系、索引等数据库文件的物理存储结构</p><h3 id="5、数据库实施"><a href="#5、数据库实施" class="headerlink" title="5、数据库实施"></a>5、数据库实施</h3><p>建立实际数据库结构、试运行、装入数据</p><h3 id="6、数据库运行和维护"><a href="#6、数据库运行和维护" class="headerlink" title="6、数据库运行和维护"></a>6、数据库运行和维护</h3><p>维护数据库的安全性、完整性控制以及系统的转储和恢复；性能的监督、分析和改进；增加新功能；发现错误和修改错误</p><h2 id="第八章：数据库编程"><a href="#第八章：数据库编程" class="headerlink" title="第八章：数据库编程"></a>第八章：数据库编程</h2><h3 id="1、嵌入式-SQL与主语言之间的通信"><a href="#1、嵌入式-SQL与主语言之间的通信" class="headerlink" title="1、嵌入式 SQL与主语言之间的通信"></a><font color='red'>1、嵌入式 SQL与主语言之间的通信</font></h3><p>SQL是描述性的面向集合的语句，负责操纵数据库；高级语言语句是过程性的面向记录的语句，负责控制程序流程通信。</p><p>在嵌入式SQL中，当主语言为C语言时，语法格式为EXEC SQL &lt;SQL语句&gt;；当主语言为Java，语法格式为 #SQL （&lt;SQL语句&gt;；</p><p>嵌入式SQL与主语言之间的通信包括：</p><p>① SQL向主语言传递执行状态信息，主要用SQL通信区实现</p><p>②主语言向SQL提供参数，主要用主变量实现</p><p>③将SQL语句查询数据库的结果交给主语言处理，主要用主变量和游标实现</p><ul><li><strong>SQL通信区:</strong></li></ul><p>SQL语句执行后的执行状态信息将送到SQL通信区中，应用程序从中取出这些信息，据此决定接下来执行的语句SQL通信区在应用程序中用EXEC SQL INCLUDE SQLCA 加以定义</p><ul><li><strong>主变量：</strong></li></ul><p>SQL语句中使用的主语言程序变量简称为主变量（即SQL使用主语言的变量）</p><p>输入主变量由应用程序赋值，SQL引用；输出主变量由SQL赋值或设置状态信息，返回应用程序</p><p>一个主变量可以附带一个任选的指示变量（整型），用来指示所指主变量的值或条件</p><p>主变量名和指示变量名前面要加冒号（:）作为标志</p><p>所有主变量和指示变量必须在SQL语句 BEGIN DECLARE SECTION 与 END DECLARE SECTION 之间进行说明</p><ul><li><strong>游标：</strong></li></ul><p>SQL是面向集合的，一条SQL 语句可以产生或处理多条记录，而主语言是面向记录的，一组变量一次只能存放一条记录，因此引入游标来协调这两种不同的处理方式</p><p>一个数据缓冲区，用来存放SQL语句的执行结果，每个游标区都有自己的名字</p><ul><li><strong>建立连接：</strong></li></ul><p>嵌入式SQL访问数据库必须先连接数据库</p><p>建立连接的嵌入式SQL 语句为EXEC SQL CONNECT TO target [AS connection-name][USER user-name]; 其中target是要连接的数据库服务器， connection—name是可选的连接名</p><p>运行过程如果要修改当前连接,对应的嵌入式语句为EXEC SQL SET CONNECTION connection-name|DEFAULT; .</p><ul><li><strong>关闭连接:</strong></li></ul><p>对应的嵌入式SQL语句为EXEC SQL DISCONNECT [connection]；</p><h3 id="2、嵌入式SQL与主语言通信的程序实例"><a href="#2、嵌入式SQL与主语言通信的程序实例" class="headerlink" title="2、嵌入式SQL与主语言通信的程序实例"></a><font color='red'>2、嵌入式SQL与主语言通信的程序实例</font></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">DECLARE</span> SECTION; <span class="hljs-comment">/*主变量说明开始*/</span><br><span class="hljs-type">char</span> Deptname[<span class="hljs-number">20</span>]；<br><span class="hljs-type">char</span> Hsno[<span class="hljs-number">9</span>];<br><span class="hljs-type">char</span> Hsname[<span class="hljs-number">20</span>]；<span class="hljs-type">char</span> Hssex[<span class="hljs-number">2</span>]; <span class="hljs-type">int</span> HSage；<br><span class="hljs-type">int</span> NEWAGE；<br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">DECLARE</span> SECTION;   <span class="hljs-comment">/*主变量说明结束*/</span><br>long SQLCODE;<br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> INCLUDE SQLCA;         <span class="hljs-comment">/*定义 SQL 通信区*/</span><br><span class="hljs-type">int</span> main(void)                  <span class="hljs-comment">/*C语言主程序开始*/</span><br><span class="hljs-type">int</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">char</span> yn;         <span class="hljs-comment">/*变量yn代表yes 或no*/</span><br>printf(&quot;Please choose the department name(CS/MA/IS): &quot;);<br>scanf(&quot;%s&quot;,deptname);           <span class="hljs-comment">/*为主变量deptname 赋值*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">CONNECT</span> <span class="hljs-keyword">TO</span> TEST<span class="hljs-variable">@localhost</span>：<span class="hljs-number">54321</span> <span class="hljs-keyword">USER</span> “<span class="hljs-keyword">SYSTEM</span>”<span class="hljs-operator">/</span>“MANAGER”； <span class="hljs-comment">/*连接数据库 TEST*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">DECLARE</span> SX <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span>  <span class="hljs-comment">/*定义游标SX*/</span><br><span class="hljs-keyword">SELECT</span> Sno，Sname，Ssex，Sage    <span class="hljs-comment">/*SX 对应的语*/</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> SDept <span class="hljs-operator">=</span> :deptname;<br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">OPEN</span> SX； <span class="hljs-comment">/*打开游标SX，指向查询结果的第一行*/</span><br><span class="hljs-keyword">for</span> (;;) <span class="hljs-comment">/*用循环结构逐条处理结果集中的记录*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">FETCH</span> SX <span class="hljs-keyword">INTO</span> :HSno,:Hsname,:HSsex,:HSage; <span class="hljs-comment">/*推进游标,将当前数据放入主变量*/</span> <br>if (SQLCA.SQLCODE<span class="hljs-operator">!=</span> <span class="hljs-number">0</span>)           <span class="hljs-comment">/*SQLCODE！=0，表示操作不成功*/</span><br>break;                           <span class="hljs-comment">/*利用SQLCA中的状态信息决定何时退出循环*/</span><br>if(count<span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)                 <span class="hljs-comment">/*如果是第一行的话，先打出行头*/</span><br>printf(&quot;in%-10s %-20s %-10s %-10sln&quot;, &quot;Sno&quot;,&quot;Sname&quot;,&quot;Ssex&quot;, &quot;Sage&quot;); <br>printf(&quot;%-10s %-20s %-10s %-10din&quot;, HSno,Hsname, Hssex, HSage);<br><span class="hljs-comment">/*打印查询结果*/</span>printf(“<span class="hljs-keyword">UPDATE</span> AGE(y<span class="hljs-operator">/</span>n)?”)； <span class="hljs-comment">/*询问用户是否要更新该学生的年龄*/</span><br>do (scanf(&quot;%c&quot;,<span class="hljs-operator">&amp;</span>yn);)<br>while(yn<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;N&#x27;</span><span class="hljs-operator">&amp;&amp;</span>yn<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;n&#x27;</span><span class="hljs-operator">&amp;&amp;</span>yn<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-operator">&amp;&amp;</span>yn<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;y&#x27;</span>); <br>if (yn<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;y&#x27;</span>llyn<span class="hljs-operator">-</span><span class="hljs-string">&#x27;Y&#x27;</span>)               <span class="hljs-comment">/*如果选择更新操作*/</span><br>printf(&quot;INPUT NEW AGE:&quot;); scanf(&quot;%d&quot;,<span class="hljs-operator">&amp;</span>NEWAGE);  <span class="hljs-comment">/*用户输入新年龄到主变量中*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">UPDATE</span> Student            <span class="hljs-comment">/*嵌入式SQL 更新语句*/</span><span class="hljs-keyword">SET</span> Sage <span class="hljs-operator">=</span> :NEWAGE<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-keyword">OF</span> SX；              <span class="hljs-comment">/*对当前游标指向的学生年龄进行更新*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">CLOSE</span> SX;                 <span class="hljs-comment">/*关闭游标SX，不再和查询结果对应*/</span><br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">COMMIT</span> WORK;              <span class="hljs-comment">/*提交更新* /</span><br><span class="hljs-comment">EXEC SQL DISCONNECT TEST；  /*断开数据库连接*/</span><br></code></pre></td></tr></table></figure><h2 id="第十章：数据库恢复技术"><a href="#第十章：数据库恢复技术" class="headerlink" title="第十章：数据库恢复技术"></a>第十章：数据库恢复技术</h2><h3 id="1、事务的概念"><a href="#1、事务的概念" class="headerlink" title="1、事务的概念"></a>1、事务的概念</h3><p>①事务是数据库操作序列，这些操作要么全做，要么全不做，是不可分割的工作单位。一个事务可以是一个sql语句，一组sql语句，或者整个程序。一般来说，一个程序包含多个事务。</p><p>②事务是恢复的基本单位，也是并发控制的基本单位。</p><h3 id="2、定义事务的SQL语句"><a href="#2、定义事务的SQL语句" class="headerlink" title="2、定义事务的SQL语句"></a>2、定义事务的SQL语句</h3><p>开始语句： BEGIN TRANSACTION；</p><p>结束语句： COMMIT； &#x2F;&#x2F;表示提交事务的所有操作</p><p>或者ROLLBACK； &#x2F;&#x2F;表示回滚，即事务运行中发生了某种故障，需要对已完成的操作进行撤销，回滚到事务开始的状态。</p><h3 id="3、事务的4个特性（ACID）：原子性，一致性，隔离性，持续性"><a href="#3、事务的4个特性（ACID）：原子性，一致性，隔离性，持续性" class="headerlink" title="3、事务的4个特性（ACID）：原子性，一致性，隔离性，持续性"></a><font color='red'>3、事务的4个特性（ACID）：原子性，一致性，隔离性，持续性</font></h3><p>①原子性：一个事务要么全做，要么全不做</p><p>②一致性：事务执行的结果必须一致。如果一个事务被迫中断，即事务中的一些操作做了，剩下的还没做，且做了的对数据库造成的修改已经存入物理数据库的话，就会造成数据库处于不一致的状态。因此事务要么全做，要么全不做，一致性和原子性是密切相关的</p><p>③隔离性：一个事务的执行不能被其他事务干扰</p><p>④持续性（也称为永久性）：一个事务一旦提交，它对数据库中数据的改变应该是永久性的</p><h3 id="4、数据库系统的故障种类：事物内部的故障、系统故障、介质故障、计算机病毒"><a href="#4、数据库系统的故障种类：事物内部的故障、系统故障、介质故障、计算机病毒" class="headerlink" title="4、数据库系统的故障种类：事物内部的故障、系统故障、介质故障、计算机病毒"></a>4、数据库系统的故障种类：事物内部的故障、系统故障、介质故障、计算机病毒</h3><p>①事务内部的故障</p><p>事务内部的故障有的是可以通过事务程序本身发现的，有的是非预期的、不能由事务程序处理的</p><p>事务故障的情况下，数据库可能处于不正确的状态。恢复程序要在不影响其他事务运行的情况下，强行回滚该事务，即撤销该事务造成的修改，这类恢复操作称为UNDO （事务撤销）</p><p>②系统故障(软故障)</p><p>系统故障是指造成系统停止运转的任何事件，使得系统要重新启动（例如硬件错误、操作系统故障、DBMS代码错误、系统断电等等）</p><p>系统故障的情况下，在系统重新启动后，恢复子系统除了需要撤销未完成的事务以外，还需要REDO （事务重做）所有已提交的事务</p><p>③介质故障(硬故障)</p><p>外存故障，如磁盘损坏、磁头碰撞、瞬时强磁场干扰等④计算机病毒</p><h3 id="5、数据库恢复技术：数据转储、登记日志文件"><a href="#5、数据库恢复技术：数据转储、登记日志文件" class="headerlink" title="5、数据库恢复技术：数据转储、登记日志文件"></a><font color='red'>5、数据库恢复技术：数据转储、登记日志文件</font></h3><p>恢复机制涉及的两个关键问题：1、如何建立冗余数据；2、如何利用这些冗余数据实施数据库的恢复恢复的基本原理：利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库</p><p>建立冗余数据的技术包括：</p><p>①数据转储</p><p>数据库管理员定期将整个数据库复制到磁带、磁盘或其他存储介质上保存起来，这些备用数据称为后备副本或后援副本。当数据库遭到破坏后可以将后备副本重新装入，但重装后备副本只能将数据库恢复到存储时的状态，要想恢复到故障发生时的状态，则必须重新运行自转储后的所有更新事务</p><p>数据转储分为：静态转储（在系统中无运行事务时进行）、动态转储（转储期间允许对数据库进行存取或修改）数据转储也可分为：海量转储（每次转储全部数据库）、增量转储（每次只转储上一次转储后更新过的数据）数据转储方法分为：动态海量转储、动态增量转储，静态海量转储、静态增量转储</p><p>②登记日志文件</p><p>日志文件是用来记录事务对数据库的更新操作的文件，有两种格式：以记录为单位、以数据块为单位.</p><ul><li>以记录为单位的日志文件</li></ul><p>需要登记的内容：各个事务的开始（BEGIN TRANSACTION）标记、各个事务的结束（COMMIT&#x2F;ROLLBACK）标记、各个事务的所有更新操作</p><p>日志记录的内容：事务标识（标明哪个是事务）、操作的类型（增删改）、操作对象（记录内部标识）、更新前数据的旧值（对插入而言，此项为空值）、更新后数据的新值（对删除而言，此项为空值）</p><ul><li>以数据块为单位的日志文件</li></ul><p>日志记录的内容：事务标识、被更新的数据块</p><p>日志文件的作用：</p><p>（1）事务故障恢复和系统故障恢复必须用日志文件</p><p>（2）在动态转储方式中必须建立日志文件，后备副本和日志文件结合才能有效恢复数据库</p><p>（3）在静态转储方式中也可以建立日志文件，当数据库毁坏后可以重新装入后备副本把数据库恢复到转储结束时刻的正确状态，然后利用日志文件，把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理</p><p>登记日志文件的两条原则：</p><p>（1）登记的次序严格按并发事务执行的时间次序</p><p>（2）必须先写日志文件，后写数据库</p><h3 id="6、不同的数据库系统故障下的恢复策略"><a href="#6、不同的数据库系统故障下的恢复策略" class="headerlink" title="6、不同的数据库系统故障下的恢复策略"></a>6、不同的数据库系统故障下的恢复策略</h3><p>①事务故障的恢复</p><p>由系统自动完成，对用户透明：利用日志文件撤销（UNDO）此事务已对数据库进行的修改</p><p>②系统故障的恢复</p><p>由系统重新启动时自动完成，不需要用户干预：撤销（UNDO）故障发生时未完成的事务，重做（REDO）已完成的事务</p><p>③介质故障的恢复</p><p>最严重的一种故障：重装数据库，重做（REDO）已完成的事务</p><p>*为避免磁盘介质出现故障影响数据库，许多数据库管理系统提供了数据库镜像功能（复制数据实现）</p><h3 id="7、具有检查点的恢复技术"><a href="#7、具有检查点的恢复技术" class="headerlink" title="7、具有检查点的恢复技术"></a>7、具有检查点的恢复技术</h3><p>这种技术在日志文件中增加了检查点记录：检查点之前的事务已经做完了，不需要重做，检查点期间和之后的事务需要重做，可以改善恢复效率</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656857834016-605613ff-a510-4d53-8cf0-28fd98dff622.png" alt="img"></p><h2 id="第十一章：并发控制"><a href="#第十一章：并发控制" class="headerlink" title="第十一章：并发控制"></a>第十一章：并发控制</h2><h3 id="1、并发控制：为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度"><a href="#1、并发控制：为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度" class="headerlink" title="1、并发控制：为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度"></a>1、并发控制：为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度</h3><p>并发控制的主要技术有：封锁、时间截、乐观控制法、多版本并发控制等</p><p>并发操作带来的数据不一致性：</p><p>①丢失修改：两个事务T1和T2 读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失</p><p>②不可重复读：指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果</p><p>③读脏数据：事务T1修改某一数据后并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致</p><h3 id="2、并发控制的基本方法：封锁（X锁、S锁）"><a href="#2、并发控制的基本方法：封锁（X锁、S锁）" class="headerlink" title="2、并发控制的基本方法：封锁（X锁、S锁）"></a><font color='red'>2、并发控制的基本方法：封锁（X锁、S锁）</font></h3><p>①排他锁&#x2F;写锁，X锁</p><p>若事务T对数据对象A加上X锁，则只允许事务T读取和修改A</p><p>事务T释放A上的锁之前：其他事务不能读取和修改A，不能再对A加任何类型的锁</p><p>②共享锁&#x2F;读锁,S锁</p><p>若事务T对数据对象A加上S锁，则事务T可以读取A，但不能修改A</p><p>事务T释放A上的S锁之前：其他事务可以读取A，可以对A加S锁，但不能修改A，也不能对A加X锁封锁类型的相容矩阵：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656857882545-dd23ca1e-9513-44fd-9f8e-ec329bda7c43.png" alt="img"></p><h3 id="3、封锁协议：约定何时申请X锁-x2F-S锁、持续时间、何时释放等等"><a href="#3、封锁协议：约定何时申请X锁-x2F-S锁、持续时间、何时释放等等" class="headerlink" title="3、封锁协议：约定何时申请X锁&#x2F;S锁、持续时间、何时释放等等"></a>3、封锁协议：约定何时申请X锁&#x2F;S锁、持续时间、何时释放等等</h3><p>①一级封锁协议</p><p>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放</p><p>②二级封锁协议</p><p>事务T在修改数据R之前必须先对其加X锁（一级封锁协议），并且其他事务在读取数据之前必须先对其加S锁，读完后即可释放S锁</p><p>③三级封锁协议</p><p>事务T在修改数据R之前必须先对其加X锁（一级封锁协议），并且其他事务在读取数据之前必须先对其加S锁，直到事务结束才释放（二级封锁协议是读完就能释放）</p><p>不同级别的封锁协议和一致性保证：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656857955898-99e19104-0edf-4109-9fd4-6735cc1b59ee.png" alt="img"></p><h3 id="4、活锁和死锁"><a href="#4、活锁和死锁" class="headerlink" title="4、活锁和死锁"></a>4、活锁和死锁</h3><p>①活锁</p><p>事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待；T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待； T4 又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求T2有可能永远等待，产生活锁</p><p>避免活锁：采用先来先服务的策略</p><p>②死锁</p><p>事务T1封锁了数据R1， T2封锁了数据R2， T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁，接着T2又申请封锁R1，因T1已封锁了R1， T2也只能等待T1，释放R1上的锁，这样T1在等待T2，而T2又在等待T1， T1和T2两个事务永远不能结束，形成死锁</p><p>解决活锁的方法：</p><p>(1)死锁的预防</p><p>1.一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</p><p>2.顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务按这个顺序实施封锁</p><p>（2）死锁的诊断与解除</p><p>诊断：1.超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</p><p>​     2.等待图法：构建事务等待图（有向图：节点表示运行的事务，边表示事务等待的情</p><p>​      况），存在回路即死锁</p><p> 解除：选择一个处理死锁代价最小的事务，将其撤销（UNDO），释放此事务持有的所有的锁</p><h3 id="5、可串行化调度：多个事务并发执行的结果-x3D-这些事务按某种次序串行执行的结果"><a href="#5、可串行化调度：多个事务并发执行的结果-x3D-这些事务按某种次序串行执行的结果" class="headerlink" title="5、可串行化调度：多个事务并发执行的结果&#x3D;这些事务按某种次序串行执行的结果"></a><font color='red'>5、可串行化调度：多个事务并发执行的结果&#x3D;这些事务按某种次序串行执行的结果</font></h3><p>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。例如现有事务T1和T2，若T1与T2的并发执行结果与先T1后T2相同，或者与先T2后T1相同，那么这个调度就是正确的，否则就是错误的</p><h3 id="6、冲突可串行化调度"><a href="#6、冲突可串行化调度" class="headerlink" title="6、冲突可串行化调度"></a>6、冲突可串行化调度</h3><p>冲突操作：指不同的事务对用一个数据的读写操作（读和写）和写写操作（写和写）</p><p>不同事务的冲突操作和同一事物的两个操作是不能交换的，如果发生交换，自然会发生错误。基于此，如果调度能保证冲突操作的次序不变，就称为冲突可串行化的调度。冲突可串行化调度一定是可串行化调度。（但是注意，可串行化调度也有可能不满足冲突可串行化）</p><h3 id="7、两段锁协议（2PL）：所有事务必须分两个阶段对数据项加锁和解锁"><a href="#7、两段锁协议（2PL）：所有事务必须分两个阶段对数据项加锁和解锁" class="headerlink" title="7、两段锁协议（2PL）：所有事务必须分两个阶段对数据项加锁和解锁"></a><font color='red'>7、两段锁协议（2PL）：所有事务必须分两个阶段对数据项加锁和解锁</font></h3><p>①获得封锁（扩展阶段）：在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</p><p>②释放封锁（收缩阶段）：在释放一个封锁之后，事务不再申请和获得任何其他封锁</p><p>若并发执行的所有事务均遵守两段锁协议，则对这些事物的任何并发调度策略都是可串行化的</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试准备第二天-数据库复习1</title>
    <link href="/2022/07/02/10%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%BA%8C%E5%A4%A9-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A01/"/>
    <url>/2022/07/02/10%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%BA%8C%E5%A4%A9-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />> 今天是面试准备的第二天，复习一下SQL语句，参考资料来自up主：https://space.bilibili.com/949043<h1 id="CREATE-x2F-DROP-x2F-ALTER-语句"><a href="#CREATE-x2F-DROP-x2F-ALTER-语句" class="headerlink" title="CREATE&#x2F;DROP&#x2F;ALTER 语句"></a><font color=red>CREATE&#x2F;DROP&#x2F;ALTER 语句</font></h1><h2 id="【模式】"><a href="#【模式】" class="headerlink" title="【模式】"></a>【模式】</h2><h3 id="定义模式-CREATE-SCHEMA"><a href="#定义模式-CREATE-SCHEMA" class="headerlink" title="定义模式 CREATE SCHEMA"></a><mark>定义模式 CREATE SCHEMA</mark></h3><p>CREATE SCHEMA 模式名 AUTHORIZATION 用户名;</p><p>eg:为用户WANG定义一个S-T模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA &quot;S-T&quot; <span class="hljs-keyword">AUTHORIZATION</span> WANG; <br></code></pre></td></tr></table></figure><p>eg.为用户WANG定义一个模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-keyword">AUTHORIZATION</span> WANG； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>未定义模式名的情况下，默认模式名为用户名<br></code></pre></td></tr></table></figure><h3 id="删除模式-DROP-SCHEMA-gt"><a href="#删除模式-DROP-SCHEMA-gt" class="headerlink" title="删除模式 DROP SCHEMA&gt;"></a><mark>删除模式 DROP SCHEMA</mark>&gt;</h3><p>DROP SCHEMA 模式名 CASCADE； &#x2F;&#x2F;级联：把该模式中所有的表、视图之类的一起删除</p><p>DROP SCHEMA 模式名 RESTRICT； &#x2F;&#x2F;限制：若该模式下已定义了表或者视图等等，则拒绝执行删除语句</p><h2 id="【基本表】"><a href="#【基本表】" class="headerlink" title="【基本表】"></a>【基本表】</h2><h3 id="定义基本表-CREATE-TABLE"><a href="#定义基本表-CREATE-TABLE" class="headerlink" title="定义基本表 CREATE TABLE"></a><mark>定义基本表 CREATE TABLE</mark></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名<br>（列名<span class="hljs-number">1</span> 数据类型 列级完整性约束条件，<span class="hljs-operator">/</span><span class="hljs-operator">/</span>如没有列级完整约束条件，可以不写<br>    列名n数据类型 列级完整性约束条件，<br>    表级完整性约束条件<span class="hljs-number">1</span>，<br>    表级完整性约束条件n<br>    );<br></code></pre></td></tr></table></figure><h4 id="（1）数据类型"><a href="#（1）数据类型" class="headerlink" title="（1）数据类型"></a>（1）数据类型</h4><table><thead><tr><th>CHAR(n)</th><th>长度为n的字符型</th></tr></thead><tbody><tr><td>VARCHAR(n)</td><td>最大长度为n的变长字符型</td></tr><tr><td>NUMBER(n)</td><td>长度为n的数字型</td></tr><tr><td>INT</td><td>长整型（4B）</td></tr><tr><td>SMALLINT</td><td>短整型（2B）</td></tr><tr><td>BIGINT</td><td>大整型（8B）</td></tr><tr><td>FLOAT(n)</td><td>精度至少为n位数字的浮点数</td></tr><tr><td>DATE</td><td>日期，格式为YYYY—MM—DD</td></tr><tr><td>TIME</td><td>时间，格式为HH：MM：SS</td></tr></tbody></table><h4 id="（2）列级完整性约束条件"><a href="#（2）列级完整性约束条件" class="headerlink" title="（2）列级完整性约束条件"></a>（2）列级完整性约束条件</h4><p>​PRIMARY KEY &#x2F;&#x2F;主码：当只有一个主码时，可直接在对应的属性列标注</p><p>​NOT NULL &#x2F;&#x2F;非空：表示该属性列不能取空值</p><p>​UNIQUE &#x2F;&#x2F;唯一值：表示该属性列只能取唯一值</p><p>​CHECK（条件） &#x2F;&#x2F;检查：检查该列是否满足某个条件，如CHECK（某属性&gt;20）</p><h4 id="（3）表级完整性约束条件"><a href="#（3）表级完整性约束条件" class="headerlink" title="（3）表级完整性约束条件"></a>（3）表级完整性约束条件</h4><p>​PRIMARY KEY（列名 1， 列名n） &#x2F;&#x2F;实体完整性：当主码由多个属性构成时，必须作为表级完整性进行定义FOREIGN KEY（列名 1） REFERENCES 被参照表（列名1） &#x2F;&#x2F;参照完整性</p><p>​eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TAB1 <br>(Sno <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>), Cno NUMBER(<span class="hljs-number">10</span>), <br> Grade <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br> <span class="hljs-keyword">PRIMARY</span> KEY(Sno, Cno),<br> <span class="hljs-keyword">FOREIGN</span> KEY(Sno) <span class="hljs-keyword">REFERENCES</span> TAB2(Sno)<br>);<br></code></pre></td></tr></table></figure><h3 id="在模式中定义表"><a href="#在模式中定义表" class="headerlink" title="在模式中定义表"></a><mark>在模式中定义表</mark></h3><p>一个模式包含多种基本表，有三种方式在模式中定义基本表。</p><h4 id="（1）创建表时指出模式"><a href="#（1）创建表时指出模式" class="headerlink" title="（1）创建表时指出模式"></a>（1）创建表时指出模式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 模式名.表名<br>(列定义语句,<br>完整性约束语句<br>);<br></code></pre></td></tr></table></figure><h4 id="（2）创建模式时直接定义表"><a href="#（2）创建模式时直接定义表" class="headerlink" title="（2）创建模式时直接定义表"></a>（2）创建模式时直接定义表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA 模式名 <span class="hljs-keyword">AUTHORIZATION</span> 用户名<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名<br>（列定义语句,<br>完整性约束语句）;<br></code></pre></td></tr></table></figure><h4 id="（3）设置所属的模式"><a href="#（3）设置所属的模式" class="headerlink" title="（3）设置所属的模式"></a>（3）设置所属的模式</h4><p>这样在创建表的时候不用给出模式名</p><h3 id="修改基本表-ALTER-TABLE"><a href="#修改基本表-ALTER-TABLE" class="headerlink" title="修改基本表 ALTER TABLE"></a><mark>修改基本表 ALTER TABLE</mark></h3><h4 id="（1）增加新的属性列"><a href="#（1）增加新的属性列" class="headerlink" title="（1）增加新的属性列"></a>（1）增加新的属性列</h4><p>​ALTER TABLE 表名 ADD新列名 数据类型 完整性约束条件；</p><p>​eg.向SC表中增加时间列，数据类型为日期型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> SC <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-type">Time</span> <span class="hljs-type">DATE</span>; <br></code></pre></td></tr></table></figure><h4 id="（2）增加列级完整性约束条件"><a href="#（2）增加列级完整性约束条件" class="headerlink" title="（2）增加列级完整性约束条件"></a>（2）增加列级完整性约束条件</h4><p>​ALTER TABLE 表名 ADD 列级完整性约束条件；</p><p>​eg.向SC表中增加Cname列必须取唯一值的约束条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> SC <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span>(Cname);<br></code></pre></td></tr></table></figure><h4 id="（3）增加表级完整性约束条件"><a href="#（3）增加表级完整性约束条件" class="headerlink" title="（3）增加表级完整性约束条件"></a>（3）增加表级完整性约束条件</h4><p>​ALTER TABLE 表名 ADD 表级完整性约束条件；</p><p>​eg.向SC表中增加Cno为外码，参照表是Student表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> SC <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> KEY(Cno) <span class="hljs-keyword">REFERENCES</span> Student(Cno); <br></code></pre></td></tr></table></figure><h4 id="（4）删除列"><a href="#（4）删除列" class="headerlink" title="（4）删除列"></a>（4）删除列</h4><p>​ALTER TABLE 表名DROP 列名CASCADE； &#x2F;&#x2F;级联：引用了该列的其他对象（例如视图）一起删除ALTER TABLE 表名 DROP 列名 RESTRICT； &#x2F;&#x2F;限制：若该列被其他对象引用，则拒绝删除</p><h4 id="（5）删除指定的完整性约束条件"><a href="#（5）删除指定的完整性约束条件" class="headerlink" title="（5）删除指定的完整性约束条件"></a>（5）删除指定的完整性约束条件</h4><p>​ALTER TABLE 表名 DROP CONSTRAINT 完整性约束名 CASCADE； &#x2F;&#x2F;级联</p><p>​ALTER TABLE 表名 DROP CONSTRAINT 完整性约束名 RESTRICT； &#x2F;&#x2F;限制</p><h4 id="（6）修改列"><a href="#（6）修改列" class="headerlink" title="（6）修改列"></a>（6）修改列</h4><p>​ALTER TABLE 表名 ALTER COLUMN 列名 数据类型；</p><p>​eg.将SC表中原有的Sage（假设是字符型）修改为整型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> SC <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> Sage <span class="hljs-type">INT</span>; <br></code></pre></td></tr></table></figure><h3 id="删除基本表DROP-TABLE"><a href="#删除基本表DROP-TABLE" class="headerlink" title="删除基本表DROP TABLE"></a><mark>删除基本表DROP TABLE</mark></h3><p>（1） DROP TABLE 表名 CASCADE； &#x2F;&#x2F;级联：删除该表时，相关的依赖对象，例如视图，都会被删除</p><p>（2） DROP TALBE 表名 RESTRICT； &#x2F;&#x2F;限制：删除该表时，若被其他表的约束所引用（例如其他表的   CHECK、FOREIGN KEY 等等），或者有视图等等，都不能被删除</p><h2 id="【索引】"><a href="#【索引】" class="headerlink" title="【索引】"></a>【索引】</h2><h3 id="建立索引-CREATE-UNIQUE-x2F-CLUSTER-INDEX"><a href="#建立索引-CREATE-UNIQUE-x2F-CLUSTER-INDEX" class="headerlink" title="建立索引 CREATE UNIQUE&#x2F;CLUSTER INDEX "></a><mark>建立索引 CREATE UNIQUE&#x2F;CLUSTER INDEX </mark></h3><h4 id="（1）建立唯一索引"><a href="#（1）建立唯一索引" class="headerlink" title="（1）建立唯一索引"></a>（1）建立唯一索引</h4><p>​CREATE UNIQUE INDEX 索引名 ON 表名（列名1次序，列名n次序）；</p><p>​eg.为SC表按学号升序和课程号降序建立唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX SCno <span class="hljs-keyword">ON</span> SC(Sno <span class="hljs-keyword">ASC</span>, Cno <span class="hljs-keyword">DESC</span>); <br></code></pre></td></tr></table></figure><h4 id="（2）建立聚簇索引"><a href="#（2）建立聚簇索引" class="headerlink" title="（2）建立聚簇索引"></a>（2）建立聚簇索引</h4><p>​CREATE CLUSTER INDEX 索引名 ON 表名（列名1次序，列名n次序）；</p><h3 id="修改索引（重命名）-ALTER-INDEX"><a href="#修改索引（重命名）-ALTER-INDEX" class="headerlink" title="修改索引（重命名） ALTER INDEX"></a><mark>修改索引（重命名） ALTER INDEX</mark></h3><p>​ALTER INDEX 旧索引名 RENAME TO 新索引名;</p><p>​eg.将SC表的SCno索引名改为 SCSno</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> INDEX SCno RENAME <span class="hljs-keyword">TO</span> SCSno;<br></code></pre></td></tr></table></figure><h3 id="删除索引DROP-INDEX"><a href="#删除索引DROP-INDEX" class="headerlink" title="删除索引DROP INDEX"></a><mark>删除索引DROP INDEX</mark></h3><p>​DROP INDEX 索引名:</p><p>​eg.删除SC表的 SCSno索引；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX SCSno;<br></code></pre></td></tr></table></figure><h1 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a><font color=red>SELECT 语句</font></h1><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a><mark>一般格式</mark></h3><p>​SELECT DISTINCT&#x2F;ALL 目标列表达式 &#x2F;&#x2F;要显示的属性列</p><p>​FROM 表名&#x2F;视图名&#x2F;&#x2F;查询的对象</p><p>​WHERE 条件表达式&#x2F;&#x2F;查询条件</p><p>​GROUP BY 列名 </p><p>​HAVING 条件表达式&#x2F;&#x2F;查询结果分组</p><p>​ORDER BY 列名 次序；&#x2F;&#x2F;最终查询结果排序</p><h2 id="【基本查询】"><a href="#【基本查询】" class="headerlink" title="【基本查询】"></a>【基本查询】</h2><h3 id="SELECT-目标列表达式"><a href="#SELECT-目标列表达式" class="headerlink" title="SELECT 目标列表达式"></a><mark>SELECT 目标列表达式</mark></h3><h4 id="（1）查询指定列：SELECT列名1，列名n"><a href="#（1）查询指定列：SELECT列名1，列名n" class="headerlink" title="（1）查询指定列：SELECT列名1，列名n"></a>（1）查询指定列：SELECT列名1，列名n</h4><p>​eg.查询TAB表的X属性列和Y属性列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> X, Y <span class="hljs-keyword">FROM</span> TAB；<br></code></pre></td></tr></table></figure><h4 id="（2）查询全部列：-SELECT"><a href="#（2）查询全部列：-SELECT" class="headerlink" title="（2）查询全部列： SELECT *"></a>（2）查询全部列： SELECT *</h4><p>​eg.查询TAB表的全部记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TAB；<br></code></pre></td></tr></table></figure><h4 id="（3）查询计算后的值：-SELECT表达式-x2F-x2F-可以是算术表达式、字符串常量、函数等等"><a href="#（3）查询计算后的值：-SELECT表达式-x2F-x2F-可以是算术表达式、字符串常量、函数等等" class="headerlink" title="（3）查询计算后的值： SELECT表达式&#x2F;&#x2F;可以是算术表达式、字符串常量、函数等等"></a>（3）查询计算后的值： SELECT表达式&#x2F;&#x2F;可以是算术表达式、字符串常量、函数等等</h4><p>​eg.查询TAB表（假定有一项属性age 记录人们的年龄）中人们的出生日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">2022</span><span class="hljs-operator">-</span>age <span class="hljs-keyword">FROM</span> TAB；<br></code></pre></td></tr></table></figure><h4 id="（4）改变查询结果的列标题：SELECT列名-别名"><a href="#（4）改变查询结果的列标题：SELECT列名-别名" class="headerlink" title="（4）改变查询结果的列标题：SELECT列名 别名"></a>（4）改变查询结果的列标题：SELECT列名 别名</h4><p>​eg.查询TAB表中的X和Y属性列，并在结果中用别名x1和y1显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Xx1, Y y1<br><span class="hljs-keyword">FROM</span> TAB；<br></code></pre></td></tr></table></figure><h4 id="（5）取消查询结果中的重复行：SELECT-DISTINCT-列名"><a href="#（5）取消查询结果中的重复行：SELECT-DISTINCT-列名" class="headerlink" title="（5）取消查询结果中的重复行：SELECT DISTINCT 列名"></a>（5）取消查询结果中的重复行：SELECT DISTINCT 列名</h4><p>​eg.查询TAB表中的X属性，并去掉结果中的重复列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> X， <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果没有用 <span class="hljs-keyword">DISTINCT</span>， 则默认为 <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">FROM</span> TAB；<br></code></pre></td></tr></table></figure><h4 id="（6）聚集函数"><a href="#（6）聚集函数" class="headerlink" title="（6）聚集函数"></a>（6）聚集函数</h4><p>​<strong>注意：</strong>当聚集函数遇到空值时，都跳过空值，只处理非空值</p><p>​    聚集函数只能用于SELECT语句和GROUP BY中的HAVING 子句（见后部分）</p><p><strong>①统计元组的个数</strong></p><p>​COUNT （*） &#x2F;&#x2F;某个元组的一个或部分取空值时，不影响统计结果</p><p>​eg.查询Student 表中学生的总数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> SC；<br></code></pre></td></tr></table></figure><p><strong>②统计某一列值的个数COUNT (DISTINCT&#x2F;ALL 列名)</strong></p><p>​如果指定DISTINCT，则表示计算时要取消重复值。若不指定，则默认为ALL，表示不取消重复值</p><p><strong>③计算某一列值的平均数（该列必须为数值型）</strong></p><p>​AVG （DISTINCT&#x2F;ALL 列名）</p><p>​eg.计算SC表中的平均成绩（Grade）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC；<br></code></pre></td></tr></table></figure><p><strong>④计算某一列值的总和（该列必须为数值型）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">SUM （<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">/</span><span class="hljs-keyword">ALL</span> 列名）<br></code></pre></td></tr></table></figure><p><strong>⑤计算某一列值的最大值&#x2F;最小值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">MAX<span class="hljs-operator">/</span><span class="hljs-built_in">MIN</span> (<span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">/</span><span class="hljs-keyword">ALL</span> 列名) <br></code></pre></td></tr></table></figure><h3 id="WHERE-条件表达式"><a href="#WHERE-条件表达式" class="headerlink" title="WHERE 条件表达式"></a><mark>WHERE 条件表达式</mark></h3><h4 id="（1）比较大小"><a href="#（1）比较大小" class="headerlink" title="（1）比较大小"></a>（1）比较大小</h4><p>常用比较运算符：&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;   !&#x3D;(或者&lt;&gt;)   !&gt;  !&lt;  </p><p>eg.查询SC表中全体计算机学生的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname <br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>eg.查询TAB表中X&gt;20的YSELECT Y</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> TAB<br><span class="hljs-keyword">WHERE</span> X<span class="hljs-operator">&gt;</span><span class="hljs-number">20</span>; <br></code></pre></td></tr></table></figure><h4 id="（2）确定范围"><a href="#（2）确定范围" class="headerlink" title="（2）确定范围"></a>（2）确定范围</h4><p><strong>WHERE 列名 BETWEEN 最小值 AND 最大值；</strong></p><p>eg.查询TAB表上 age在20到30 之间的人的name和 sex</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, sex<br><span class="hljs-keyword">FROM</span> TAB<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p><strong>WHERE 列名 NOT BETWEEN 最小值 AND 最大值；</strong></p><p>eg.查询TAB表上age不在20到30之间的人的name 和sex</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, sex<br><span class="hljs-keyword">FROM</span> TAB<br><span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>; <br></code></pre></td></tr></table></figure><h4 id="（3）-确定集合"><a href="#（3）-确定集合" class="headerlink" title="（3） 确定集合"></a>（3） 确定集合</h4><p><strong>WHERE 列名 IN （’列名1’， ‘列名n’）；</strong></p><p>eg. 在SC表的Sdept列中查找属于计算机专业（CS）、数学专业（MA）、信息专业（IS）的学生姓名（S_name）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> S_name<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CS&#x27;</span>, <span class="hljs-string">&#x27;MA&#x27;</span>, <span class="hljs-string">&#x27;IS&#x27;</span>);<br><span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> （<span class="hljs-string">&#x27;列名1&#x27;</span>， <span class="hljs-string">&#x27;列名n&#x27;</span>）；<br></code></pre></td></tr></table></figure><p><strong>WHERE 列名 NOT IN （’列名1’， ‘列名n’）；</strong></p><p>eg. 在SC表的Sdept列中查找既不是计算机专业（CS）也不是数学专业（MA）的学生姓名（S_name）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> S_name<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CS&#x27;</span>, <span class="hljs-string">&#x27;MA&#x27;</span>); <br></code></pre></td></tr></table></figure><h4 id="4-字符匹配"><a href="#4-字符匹配" class="headerlink" title="(4)字符匹配"></a>(4)字符匹配</h4><p>通配符：写在字符串当中，用来求一些有特殊条件的字符串</p><p><strong>% 表示任意长度（可以为0）的字符串。如a%b，表示以a开头，b结尾的任意长度字符串</strong></p><p><strong>_表示单个字符。如a_b，表示以a开头b结尾的长度为3的字符串</strong></p><p>注意：在ASCII 码表中，一个汉字的长度为2</p><p>转义字符：字符串中紧跟在转义字符后的字符”%或_’不再具有通配符的含义设置转义字符的语句为ESCAPE’符号’，该符号可以自己设置，一般采用’&#39;。例如需要查找的字符串为’50%’，那么应写’50%‘，否则会查找以50开头的不定长字符串</p><p><strong>WHERE 列名 LIKE ‘字符串’ ESCAPE ‘V’；</strong></p><p>eg. 在Student表中查找所有姓刘且全名为3个汉字的学生的Sname，Sno 和Ssex</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname, Sno, Ssex<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_-&#x27;</span>;<br></code></pre></td></tr></table></figure><p>eg. 在SC表中查找课程名（Cname）为DB_Design的课程号（Cno）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Cno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Cname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;DBY Design&#x27;</span> <span class="hljs-keyword">ESCAPE</span> V<span class="hljs-string">&#x27;; </span><br><span class="hljs-string">WHERE 列名 NOT LIKE &quot;符&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;&#x27;</span>；<br></code></pre></td></tr></table></figure><p>eg.在Student表中查找所有不姓刘的学生的Sname</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sname <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;刘%&#x27;</span>; <br></code></pre></td></tr></table></figure><h4 id="5-空值查询"><a href="#5-空值查询" class="headerlink" title="(5)空值查询"></a>(5)空值查询</h4><p><strong>WHERE 列名 IS NULL；</strong></p><p>eg. 在SC表中查询缺少成绩（Grade）的学生的姓名（Sname）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>；<br></code></pre></td></tr></table></figure><p>eg.查询全部有成绩（Grade）的学生的姓名（Sname）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>; <br></code></pre></td></tr></table></figure><h4 id="（6）多重条件查询"><a href="#（6）多重条件查询" class="headerlink" title="（6）多重条件查询"></a>（6）多重条件查询</h4><p>WHERE 条件表达式AND 条件表达式；</p><p>WHERE条件表达式 OR 条件表达式；</p><p>可以用AND 或者OR将上述各类条件表达式组合在一起。其中，AND的优先级大于OR</p><h3 id="GROUP-BY-列名-HAVING-条件表达式"><a href="#GROUP-BY-列名-HAVING-条件表达式" class="headerlink" title="GROUP BY 列名 HAVING 条件表达式"></a><mark>GROUP BY 列名 HAVING 条件表达式</mark></h3><p>用于将查询结果按某一列或多列的值分组，值相等的为一组</p><p>目的是细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，每一组都有一个函数值</p><h4 id="（1）-GROUP-BY-列名"><a href="#（1）-GROUP-BY-列名" class="headerlink" title="（1） GROUP BY 列名"></a>（1） GROUP BY 列名</h4><p>eg.求SC表中，各个课程号（Cno）下相应的选课人数（Sno）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Cno, <span class="hljs-built_in">COUNT</span>(Sno)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Cno； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>表示具有相同Cno 值的元组为一组，对每一组用COUNT进行计算，求得该组的人数<br></code></pre></td></tr></table></figure><h4 id="（2）-GROUP-BY-列名-HAVING-选条件"><a href="#（2）-GROUP-BY-列名-HAVING-选条件" class="headerlink" title="（2） GROUP BY 列名 HAVING 选条件"></a>（2） GROUP BY 列名 HAVING 选条件</h4><p>与WHERE 的区别：</p><ul><li>HAVING 用于从组中选择满足条件的组</li><li>WHERE 用于从基本表或视图中选择满足条件的元组（注意： WHERE子句不可以接聚集函数）</li></ul><p>eg. 在SC表中查询平均成绩（Grade）大于等于90的学生学号（Sno）和平均成绩（Grade）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Grade<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade)<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span><span class="hljs-number">90</span>; <br></code></pre></td></tr></table></figure><h3 id="ORDER-BY-次序"><a href="#ORDER-BY-次序" class="headerlink" title="ORDER BY 次序"></a><mark>ORDER BY 次序</mark></h3><p><strong>ORDER BY 列名1 列名n ASC</strong></p><p>对查询结果按照一个或多个属性列的升序排列（若不表明次序，默认为升序）</p><p><strong>ORDER BY 列名1 列名n DESC</strong></p><p>对查询结果按照一个或多个属性列的降序排列</p><p>eg.查序SC表中Cno为3的学生的Sno和Grade，结果按照Grade的降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Grade<br><span class="hljs-keyword">FROM</span> SCWHERE Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Grade <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h2 id="【连接查询】"><a href="#【连接查询】" class="headerlink" title="【连接查询】"></a>【连接查询】</h2><h3 id="两表连接查询"><a href="#两表连接查询" class="headerlink" title="两表连接查询"></a><mark>两表连接查询</mark></h3><p><strong>WHERE 表名1.列名1比较运算符 表名2.列名2；&#x2F;&#x2F;当列名在参与连接的各表中唯一时，可省去表名前缀</strong></p><p>eg.查询Student 表中学生的情况以及SC表中他们对应的选课情况，要求在一个查询结果中展示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.<span class="hljs-operator">*</span>， SC.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>若两个表中有相同名的属性列，自然连接<span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>用 Sno作为连接字段，将两个表连接在一起<br><span class="hljs-comment">/*若想获得自然连接，则列举全部属性列，并去掉一个相同的属性列即可。可以将上述SELECT语句改写如下*/</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br></code></pre></td></tr></table></figure><p>eg. 在Student表和SC表中，查询选修了2号课程（Cno&#x3D;’2’）且成绩（Grade）在90分以上的学生学号（Sno）和姓名（Sname）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.Sno， Sname<br><span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC.Sno <span class="hljs-keyword">AND</span> SC.Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">AND</span> SC.Grade <span class="hljs-operator">&gt;</span><span class="hljs-number">90</span>； <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">AND</span> 用作多重条件<br></code></pre></td></tr></table></figure><h3 id="单表连接查询"><a href="#单表连接查询" class="headerlink" title="单表连接查询"></a><mark>单表连接查询</mark></h3><p>eg.在Course 表中查询先修课的先修课（即间接先修课），其中课程号为Cno，先修课程号为Cpno</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> FIRST.Cno, SECOND.Cpno<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>利用下述别名进行选择<br><span class="hljs-keyword">FROM</span> Course <span class="hljs-keyword">FIRST</span>， Course <span class="hljs-keyword">SECOND</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>为这个表取两个别名<br><span class="hljs-keyword">WHERE</span> FIRST.Cpno<span class="hljs-operator">=</span>SECOND.Cno;<br></code></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a><mark>外连接查询</mark></h3><p>将悬浮元组保留在结果关系中，没有属性值的位置填上NULL</p><h4 id="1-左外连接查询"><a href="#1-左外连接查询" class="headerlink" title="(1)左外连接查询"></a>(1)左外连接查询</h4><p><strong>FROM 表名1 LEFT OUTER JOIN 表名2 ON (连接条件); &#x2F;   &#x2F;也可以将ON 换成 USING，去掉结果中的重复值</strong></p><h4 id="2-右外连接查询"><a href="#2-右外连接查询" class="headerlink" title="(2)右外连接查询"></a>(2)右外连接查询</h4><p><strong>FROM 表名1 RIGHT OUTER JOIN 表名 2 ON (连接条件);</strong></p><p>eg. 以Student表为主体列，排出每个学生的基本情况和选课情况（SC表中），没选课的学生依旧保留在结果中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br><span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (Student.Sno<span class="hljs-operator">=</span>SC.Sno); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>左外连接 <br></code></pre></td></tr></table></figure><h3 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a><mark>多表连接查询</mark></h3><p><strong>WHERE 表名1.列名1&#x3D;表名2.列名2 AND表名2.列名2&#x3D;表名3.列名3</strong></p><p>多表连接一般是先进行两个表的连接操作，再将其连接结果与第三个表执行连接</p><p>eg. A Student 表、SC表、Course表中查询每个学生的学号（Sno）、姓名（Sname）、课程（Cname）和成绩（Grade）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Cname, Grade <br><span class="hljs-keyword">FROM</span> Student, SC, Course<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC.Sno <span class="hljs-keyword">AND</span> SC.Cno<span class="hljs-operator">=</span>Course.Cno;<br></code></pre></td></tr></table></figure><h2 id="【嵌套查询】"><a href="#【嵌套查询】" class="headerlink" title="【嵌套查询】"></a>【嵌套查询】</h2><p>查询块： SELECT—FROM—WHERE</p><p>嵌套查询：将一个查询块嵌套在另一个查询块的WHERE 子句或者HAVING子句</p><p>​     其中，上层的查询块称为外层查询&#x2F;父查询；下层的查询块称为内层查询&#x2F;子查询</p><p><strong>注意</strong>：子查询的SELECT 语句中不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排序</p><h2 id="IN-子查询"><a href="#IN-子查询" class="headerlink" title="IN-子查询"></a><mark>IN-子查询</mark></h2><p>父查询与子查询之间用IN连接</p><p><strong>WHERE 列名 IN (子查询)；</strong></p><p>eg.查找与刘晨同一个专业的同学</p><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sdept<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;刘晨;</span><br></code></pre></td></tr></table></figure><p>查找结果为刘晨在CS专业，之后再查找CS专业的学生</p><h4 id="②"><a href="#②" class="headerlink" title="②"></a>②</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Sname, Sdept<br><span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>; <br></code></pre></td></tr></table></figure><p>将上述①②构造为嵌套查询 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Sname, Sdept <br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> Sdept <br>   <span class="hljs-keyword">FROM</span> Student<br>    <span class="hljs-keyword">WHERE</span> Sname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;刘晨）： //本例的子查询条件不依赖于父查询，这类子查询称为不相关子查询</span><br></code></pre></td></tr></table></figure><h3 id="比较运算符—子查询"><a href="#比较运算符—子查询" class="headerlink" title="比较运算符—子查询"></a><mark>比较运算符—子查询</mark></h3><p>父查询与子查询之间用比较运算符连接</p><p><strong>WHERE 列名 比较运算符(子查询); &#x2F;&#x2F;当用户能确切知道内层查询返回的是单个值时，可用比较运算符连接</strong></p><p>eg.在SC表中，找出每个学生（Sno）超过他自己选修课程平均成绩（Grade）的课程号（Cno）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Cno <br><span class="hljs-keyword">FROM</span> SC x<span class="hljs-operator">/</span><span class="hljs-operator">/</span>x是表SC的别名，又称为元组变量，可以用来表示SC的一个元组<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-keyword">FROM</span> SC y<br><span class="hljs-keyword">WHERE</span> y.Sno<span class="hljs-operator">=</span>x.Sno）；<br> <span class="hljs-comment">/*本例的子查询条件依赖于父查询，这类子查询称为相关子查询，整个查询称为相关嵌套查询*/</span><br></code></pre></td></tr></table></figure><h3 id="ANY-x2F-ALL-子查询"><a href="#ANY-x2F-ALL-子查询" class="headerlink" title="ANY&#x2F;ALL-子查询"></a><mark>ANY&#x2F;ALL-子查询</mark></h3><p><strong>WHERE 列名 比较运算符ANY&#x2F;ALL (子查询);&#x2F;&#x2F;有的系统中ANY 用SOME代替</strong></p><table><thead><tr><th>谓词</th><th>语义</th><th>与聚集函数或IN的等价转换</th></tr></thead><tbody><tr><td>&gt;ANY</td><td>大于子查询结果中的某个值</td><td>&gt;MIN</td></tr><tr><td>&gt;ALL</td><td>大于子查询结果中的所有值</td><td>&gt;MAX</td></tr><tr><td>&lt;ANY</td><td>小于子查询结果中的某个值</td><td>&lt;MAX</td></tr><tr><td>&lt;ALL</td><td>小于子查询结果中的所有值</td><td>&lt;MIN</td></tr><tr><td>&gt;&#x3D;ANY</td><td>大于等于子查询结果中的某个值</td><td>&gt;&#x3D;MIN</td></tr><tr><td>&gt;&#x3D;ALL</td><td>大于等于子查询结果中的所有值</td><td>&gt;&#x3D;MAX</td></tr><tr><td>&lt;&#x3D;ANY</td><td>小于等于子查询结果中的某个值</td><td>&lt;&#x3D;MAX</td></tr><tr><td>&lt;&#x3D;ALL</td><td>小于等于子查询结果中的所有值</td><td>&lt;&#x3D;MIN</td></tr><tr><td>&#x3D;ANY</td><td>等于子查询结果中的某个值</td><td>IN</td></tr><tr><td>&#x3D;ALL</td><td>等于子查询结果中的所有值</td><td>&#x2F;- -</td></tr><tr><td>&#x3D;(或&lt;&gt;)ANY</td><td>不等于子查询结果中的某个值</td><td>&#x2F;- -</td></tr><tr><td>!&#x3D;(或&lt;&gt;)ALL</td><td>不等于子查询结果中的任何值</td><td>NOT IN</td></tr></tbody></table><p>eg. 在Student表中，查询不是CS专业的学生中，比CS专业任意一个学生年纪小的学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname, Sage<br><span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-keyword">ANY</span><br> (<span class="hljs-keyword">SELECT</span> Sage <span class="hljs-keyword">FROM</span> Student<br>  <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span>)<br>  <span class="hljs-keyword">AND</span> Sdept <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;CS&#x27;</span>； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>注意这是父查询块中的条件<br></code></pre></td></tr></table></figure><h3 id="EXISTS-子查询"><a href="#EXISTS-子查询" class="headerlink" title="EXISTS-子查询"></a><mark>EXISTS-子查询</mark></h3><p>EXISTS 代表存在量词（与之对应的为NOT EXISTS）</p><p>EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值’true’或逻辑假值’false”逻辑蕴涵表达：</p><h2 id="【集合查询】"><a href="#【集合查询】" class="headerlink" title="【集合查询】"></a>【集合查询】</h2><p>多个SELECT语句的结果可以进行集合的并（UNION）、交（INTERSECT）、差（EXCEPT）操作</p><p><strong>注意：</strong>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同</p><p><strong>SELECT 语句 1 UNION&#x2F;INTERSECT&#x2F;EXCEPT SELECT 语句 2</strong></p><h3 id="UNION-并操作"><a href="#UNION-并操作" class="headerlink" title="UNION 并操作"></a><mark>UNION 并操作</mark></h3><p>UNION 合并查询结果时，系统会自动去掉重复元组，若需保留，则采用UNION ALL</p><p>eg1. 在Student 表中查询CS专业的学生和年龄不大于19岁的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <br>Student <br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span> <span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student <br>WEHRE Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><p>eg2. 在SC表中查询选修了课程1或者课程2的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br>WEHRE Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span>; <br></code></pre></td></tr></table></figure><h3 id="INTERSECT-交操作"><a href="#INTERSECT-交操作" class="headerlink" title="INTERSECT 交操作"></a><mark>INTERSECT 交操作</mark></h3><p>eg.查询既选修了课程1又选修了课程2的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SCWHERE Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br>WEHRE Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="EXCEPT-差操作"><a href="#EXCEPT-差操作" class="headerlink" title="EXCEPT 差操作"></a><mark>EXCEPT 差操作</mark></h3><p>eg.查询CS专业的学生与年龄不大于19岁的学生的差集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span> <span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> Student WEHRE Sage<span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure><h2 id="【基于派生表的查询】"><a href="#【基于派生表的查询】" class="headerlink" title="【基于派生表的查询】"></a>【基于派生表的查询】</h2><p>子查询出现在FROM子句时，子查询将生成临时的派生表，成为主查询的查询对象。</p><p><strong>FROM （子查询） AS别名（属性列名1，属性列名n）；</strong></p><p>&#x2F;&#x2F;如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT 子句后面的列名为其默认属性</p><p>&#x2F;&#x2F;AS 可以省略，但必须为派生表关系指定一个别名；</p><p>eg1.找出每个学生超过他自己选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Cno<br><span class="hljs-keyword">FROM</span> SC, (<span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">Avg</span>(Grade) <br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno) <span class="hljs-keyword">AS</span> Avg_sc(avg_sno, avg_grade) <br><span class="hljs-keyword">WHERE</span> SC.Sno <span class="hljs-operator">=</span> Avg_sc.avg_sno <span class="hljs-keyword">AND</span> SC.Grade<span class="hljs-operator">&gt;=</span>Avg_sc.avg_grade;<br></code></pre></td></tr></table></figure><p>eg2.查询所有选修了1号课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student, (SECLECT Sno <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> Cno<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">AS</span> SC1 <br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC1.Sno；<br></code></pre></td></tr></table></figure><h1 id="INSERT-x2F-UPDATE-x2F-DELETE-语句"><a href="#INSERT-x2F-UPDATE-x2F-DELETE-语句" class="headerlink" title="INSERT&#x2F;UPDATE&#x2F;DELETE 语句"></a><font color='red'>INSERT&#x2F;UPDATE&#x2F;DELETE 语句</font></h1><h2 id="插入数据INSERT"><a href="#插入数据INSERT" class="headerlink" title="插入数据INSERT "></a><mark>插入数据INSERT </mark></h2><h3 id="1-插入元组"><a href="#1-插入元组" class="headerlink" title="(1)插入元组"></a>(1)插入元组</h3><p><strong>INSERT</strong> <strong>INTO 表名(列名1,列名n)</strong></p><p><strong>VALUES （常量1，常量n）; &#x2F;&#x2F;字符串常量要用单引号（’）括起来</strong></p><p>假设现有TAB1表，共有C1到C4四列，其中C4列是字符串常量</p><h4 id="situation1-明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列）"><a href="#situation1-明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列）" class="headerlink" title="situation1. 明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列）"></a>situation1. 明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> TAB1 (C1, C2, C3, C4) <br><span class="hljs-keyword">VALUES</span> （<span class="hljs-number">1</span>， <span class="hljs-number">2</span>， <span class="hljs-number">3</span>， <span class="hljs-string">&#x27;4&#x27;</span>）；<br></code></pre></td></tr></table></figure><h4 id="situation2-仅指出在TAB1-表上插入元组（插入数据包含全部属性列）"><a href="#situation2-仅指出在TAB1-表上插入元组（插入数据包含全部属性列）" class="headerlink" title="situation2.仅指出在TAB1 表上插入元组（插入数据包含全部属性列）"></a>situation2.仅指出在TAB1 表上插入元组（插入数据包含全部属性列）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> TAB1<br><span class="hljs-keyword">VALUES</span> （<span class="hljs-number">1</span>， <span class="hljs-number">2</span>， <span class="hljs-number">3</span>， <span class="hljs-string">&#x27;4&#x27;</span>）； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这种情况表示要在TAB1 表全部各列赋值，且插入数据的顺序必须和列的顺序对应<br></code></pre></td></tr></table></figure><h4 id="situation3-明确给出新增元组要在哪些属性列上赋值（插入数据不包含全部属性列）"><a href="#situation3-明确给出新增元组要在哪些属性列上赋值（插入数据不包含全部属性列）" class="headerlink" title="situation3. 明确给出新增元组要在哪些属性列上赋值（插入数据不包含全部属性列）"></a>situation3. 明确给出新增元组要在哪些属性列上赋值（插入数据不包含全部属性列）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> TAB1 (C1, C2, C3)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这种情况下, C4 列会被赋为<span class="hljs-keyword">NULL</span> 注意：当表定义说明了<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> 时，不赋值会出错<br></code></pre></td></tr></table></figure><h4 id="situation4-仅指出在TAB1-表上插入元组（插入数据不包含全部属性列）"><a href="#situation4-仅指出在TAB1-表上插入元组（插入数据不包含全部属性列）" class="headerlink" title="situation4. 仅指出在TAB1 表上插入元组（插入数据不包含全部属性列）"></a>situation4. 仅指出在TAB1 表上插入元组（插入数据不包含全部属性列）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> TAB1<br><span class="hljs-keyword">VALUES</span> （<span class="hljs-number">1</span>， <span class="hljs-number">2</span>， <span class="hljs-number">3</span>， <span class="hljs-keyword">NULL</span>）； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这种情况必须明确给出未赋值的属性列为<span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h3 id="（2）插入子查询结果"><a href="#（2）插入子查询结果" class="headerlink" title="（2）插入子查询结果"></a>（2）插入子查询结果</h3><p><strong>INSERT</strong></p><p><strong>INTO 表名(属性列1,属性列n)</strong></p><p><strong>子查询；&#x2F;&#x2F;子查询嵌套在INSERT语句中生成要插入的批量数据</strong></p><p>eg.假设现有TAB1表（如上），并按C1列分组求C2列的平均值，并存入TAB2表（其中TAB2 表的C1列存放C1， avg_C2 列存放 C2 列的均值）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">INTO</span> TAB2 (C1, avg_C2)<br> <span class="hljs-keyword">SELECT</span> C1, <span class="hljs-built_in">AVG</span>(C2) <br><span class="hljs-keyword">FROM</span> TAB1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> C1;<br></code></pre></td></tr></table></figure><h2 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据 UPDATE"></a><mark>修改数据 UPDATE</mark></h2><p><strong>UPDATE 表名</strong></p><p><strong>SET 列名1&#x3D;表达式1，列名n&#x3D;表达式n</strong></p><p><strong>WHERE 条件；&#x2F;&#x2F;修改指定表中满足WHERE 子句条件的元组；若省略WHERE，表示要修改表中的所有元组</strong></p><h4 id="situation1-修改某一个元组的值"><a href="#situation1-修改某一个元组的值" class="headerlink" title="situation1. 修改某一个元组的值"></a>situation1. 修改某一个元组的值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> TAB1 <span class="hljs-keyword">SET</span> C4<span class="hljs-operator">=</span><span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-keyword">WHERE</span> C1<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="situation2-修改多个元组的值-UPDATE-TAB1"><a href="#situation2-修改多个元组的值-UPDATE-TAB1" class="headerlink" title="situation2. 修改多个元组的值 UPDATE TAB1"></a>situation2. 修改多个元组的值 UPDATE TAB1</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> C3<span class="hljs-operator">=</span>C3<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="situation3-带子查询的修改语句-UPDATE-TAB1"><a href="#situation3-带子查询的修改语句-UPDATE-TAB1" class="headerlink" title="situation3. 带子查询的修改语句 UPDATE TAB1"></a>situation3. 带子查询的修改语句 UPDATE TAB1</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> C4<span class="hljs-operator">=</span><span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-keyword">WHERE</span> C1 <span class="hljs-keyword">IN</span><br>（<span class="hljs-keyword">SELECT</span> C1FROM TAB2<br><span class="hljs-keyword">WHERE</span> avg_C2<span class="hljs-operator">=</span><span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><h2 id="删除数据DELETE"><a href="#删除数据DELETE" class="headerlink" title="删除数据DELETE"></a><mark>删除数据DELETE</mark></h2><p>DELETE</p><p>FROM 表名</p><p>WHERE条件;     &#x2F;&#x2F;删除指定表中满足WHERE子句条件的元组；若省略WHERE，表示要删除表中的所有元组注意：DELETE 语句删除的是表中的数据，并不是表的定义，表的定义仍在数据字典当中</p><h4 id="situation1-删除某一个元组的值DELETE"><a href="#situation1-删除某一个元组的值DELETE" class="headerlink" title="situation1. 删除某一个元组的值DELETE"></a>situation1. 删除某一个元组的值DELETE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> TAB1WHERE C1<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="situation2-删除多个元组的值-DELETE"><a href="#situation2-删除多个元组的值-DELETE" class="headerlink" title="situation2. 删除多个元组的值 DELETE"></a>situation2. 删除多个元组的值 DELETE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> TAB1; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>TAB1 将变成空表<br></code></pre></td></tr></table></figure><h4 id="situation3-带子查询的删除语句"><a href="#situation3-带子查询的删除语句" class="headerlink" title="situation3. 带子查询的删除语句"></a>situation3. 带子查询的删除语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> TAB1 <br><span class="hljs-keyword">WHERE</span> C1 <span class="hljs-keyword">IN</span> <br>(<span class="hljs-keyword">SELECT</span> C1 <br><span class="hljs-keyword">FROM</span> TAB2 <br><span class="hljs-keyword">WHERE</span> avg_C2<span class="hljs-operator">=</span><span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="VIEW-视图"><a href="#VIEW-视图" class="headerlink" title="VIEW 视图"></a><font color='red'>VIEW 视图</font></h1><h2 id="定义视图CREATE-VIEW"><a href="#定义视图CREATE-VIEW" class="headerlink" title="定义视图CREATE VIEW"></a><mark>定义视图CREATE VIEW</mark></h2><p><strong>CREATE VIEW 视图名（列名1，列名n） &#x2F;&#x2F;若省略列名，则该视图由子查询中SELECT的目标列字段组成</strong></p><p><strong>AS 子查询</strong></p><p><strong>WITH CHECK OPTION； &#x2F;&#x2F;若添加该句，则表示对视图进行增删改时要满足子查询中的条件表达式</strong></p><p>在以下情况中必须明确指定组成视图的列名：</p><p>1.某个目标列不是单纯的列名，而是聚集函数或列表达式</p><p>\2. 多表连接时选出了几个同名列作为视图的字段</p><p>3.需要在视图中为某个列启用新的更合适的名字</p><p>行列子集视图：由单个基本表导出，仅去掉了基本表的某些行和某些列，但保留了主码</p><p>若某些视图是建立在另一个表的全部属性列上的，即视图与基本表的各列是一一对应的。那么当修改基本表的结构时，基本表和视图的映像关系会被破坏。这种情况最好在修改基本表后删除该视图，然后重建该视图</p><p>eg1. 建立TAB1的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> V_TAB1 <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> C1, C2, C3, C4<br><span class="hljs-keyword">FROM</span> TAB1<br><span class="hljs-keyword">WHERE</span> C1<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>eg2.建立C4为4时TAB1的视图，并保证以后每次增删改时都要满足C4为4的条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> V_TAB2<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> C1, C2, C3, C4 <br><span class="hljs-keyword">FROM</span> TAB1<br><span class="hljs-keyword">WHERE</span> C4<span class="hljs-operator">=</span><span class="hljs-string">&#x27;4&#x27;</span> <br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION;<br></code></pre></td></tr></table></figure><p>eg3.建立在一个或多个已定义号的视图上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> V_TAB3<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> C1, C2, C3 <br><span class="hljs-keyword">FROM</span> V_TAB1 <br><span class="hljs-keyword">WHERE</span> C2<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>eg4.为减少冗余数据，定义基本表时一般只存放基本数据。当需要使用计算得出的派生数据时，可以设置在视图中的派生属性列上，也称为虚拟列。带虚拟列的视图也称为带表达式的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> V_TAB4(C1, new_C2)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> C1, <span class="hljs-number">10</span><span class="hljs-operator">+</span>C2 <br><span class="hljs-keyword">FROM</span> TAB1；<br></code></pre></td></tr></table></figure><p>eg5.分组视图:带有聚集函数和GROUP BY子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> V_TAB5(C1, avg_C2) <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> C1, <span class="hljs-built_in">AVG</span>(C2)<br><span class="hljs-keyword">FROM</span> TAB1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> C1; <br></code></pre></td></tr></table></figure><h2 id="删除视图DROP-VIEW"><a href="#删除视图DROP-VIEW" class="headerlink" title="删除视图DROP VIEW"></a><mark>删除视图DROP VIEW</mark></h2><p>DROP VIEW 视图名 CASCADE； &#x2F;&#x2F;若使用 CASCADE级联删除语句，则将把该视图导出的所有视图一并删除eg1.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> V_TAB2; <br></code></pre></td></tr></table></figure><p>eg2.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> V_TAB1 CASCADE； <span class="hljs-operator">/</span><span class="hljs-operator">/</span>由 V_TAB1 导出的 V_TAB3 也一并删除<br></code></pre></td></tr></table></figure><h2 id="查询视图和更新视图"><a href="#查询视图和更新视图" class="headerlink" title="查询视图和更新视图"></a><mark>查询视图和更新视图</mark></h2><p>视图定义后，对视图进行查询和更新的语句和语法与基本表相同</p><p>视图的查询与更新最终都会转换为对基本表的查询和更新，这一过程也被称为视图消解一般来说，行列子集视图的查询和更新都可以顺利转换，其他则不一定</p><h1 id="空值"><a href="#空值" class="headerlink" title="空值"></a><font color=red>空值</font></h1><h2 id="判断一个属性是否为空值"><a href="#判断一个属性是否为空值" class="headerlink" title="判断一个属性是否为空值"></a><mark>判断一个属性是否为空值</mark></h2><p>属性 IS NULL</p><p>属性 IS NOT NULL</p><h2 id="空值的运算"><a href="#空值的运算" class="headerlink" title="空值的运算"></a><mark>空值的运算</mark></h2><p>空值与另一个值的算术运算结果为空值</p><p>空值与另一个值的比较运算结果为UNKNOWN</p><p>在查询语句中，只有使WHERE和HAVING 子句的选择条件为TRUE 的元组才会被选出作为输出结果（即不包括UNKNOWN 的情况）</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试准备第一天-常见问题准备</title>
    <link href="/2022/07/01/09%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%B8%80%E5%A4%A9-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/"/>
    <url>/2022/07/01/09%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%AC%AC%E4%B8%80%E5%A4%A9-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 第一部分：无领导面试（这部分是自己写的答案，可能不对，只提供参考）<h3 id="1-如何预防金融风险？"><a href="#1-如何预防金融风险？" class="headerlink" title="1.如何预防金融风险？"></a>1.如何预防金融风险？</h3><ul><li>进一步健全金融风险预警体系</li><li>加大金融基础设施的建设力度</li><li>推动金融市场基础制度的建设和完善</li><li>充分发挥监管机制的作用</li><li>做好重点领域的金融风险防控工作</li></ul><h3 id="2-某农产品公司面对资金短缺问题，现只有20万元资金可供使用，需解决以下问题："><a href="#2-某农产品公司面对资金短缺问题，现只有20万元资金可供使用，需解决以下问题：" class="headerlink" title="2.某农产品公司面对资金短缺问题，现只有20万元资金可供使用，需解决以下问题："></a>2.某农产品公司面对资金短缺问题，现只有20万元资金可供使用，需解决以下问题：</h3><ul><li>1.因工作导致工伤员工的医药费</li><li>2.工作大楼及办公室的装修及修缮</li><li>3.员工上个季度的业绩奖励</li><li>4.即将到来的节日员工福利</li><li>5.员工的日常出行交通补贴</li></ul><p>讨论：如果你是相关人员请问如何排列事项优先级，以及如何分配资金。<br>答：员工的生命安全第一位，所以首先是医药费，按照相关法律法规基于赔偿；然后是填补之前的空缺，上个季度的业绩奖励，按照员工业绩成绩进行合理发放，然后是员工入场的雏形交通部图二和即将到来节日的福利，最后剩下的钱评估是都足够装修，如果够了就进行施工，不够继续等待下一笔资金的到来。</p><h3 id="3-对金融风险进行排序，一共9个金融风险：信用风险、监管风险、法律风险、操作风险、技术性风险、市场风险、信息泄露风险、支付风险、结算风险。"><a href="#3-对金融风险进行排序，一共9个金融风险：信用风险、监管风险、法律风险、操作风险、技术性风险、市场风险、信息泄露风险、支付风险、结算风险。" class="headerlink" title="3.对金融风险进行排序，一共9个金融风险：信用风险、监管风险、法律风险、操作风险、技术性风险、市场风险、信息泄露风险、支付风险、结算风险。"></a>3.对金融风险进行排序，一共9个金融风险：信用风险、监管风险、法律风险、操作风险、技术性风险、市场风险、信息泄露风险、支付风险、结算风险。</h3><ul><li>依据风险性规则对上述金融风险进行排序。</li><li>找出最重要的风险，并提出三点降低风险的建议。</li></ul><p>答：九类风险有些多，我感觉可以先进性大致的一个归类，技术性风险、信息泄露风险、支付风险、结算风险这些归为技术类风险，现在就剩下：信用、监管、法律、操作、市场、技术类。再把监管和法律归为一类。现在就有这样一个递进关系，监管法律不严格，操作就会失误，出现技术性风险，出现技术性风险（比如隐私泄露）就会造成信用低下，进而影响市场，所以解决问题的源头在法律和监管，按照这个逻辑顺序进行一次排序就是重要程度，因为我们进行风险排序的目的是解决问题、降低风险，就要从源头出发。<br>对于法律监管风险，建议有：首先完善公司规章制度，培训员工的法律意识；然后健全监管体制，可以设置举报信箱或者举报奖励制度。</p><h2 id="第二部分：半结构化面试（这部分有些在网上找的，自己补充完善）"><a href="#第二部分：半结构化面试（这部分有些在网上找的，自己补充完善）" class="headerlink" title="第二部分：半结构化面试（这部分有些在网上找的，自己补充完善）"></a>第二部分：半结构化面试（这部分有些在网上找的，自己补充完善）</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><ul><li>各位面试官大家好，很荣幸能参加此次的面试。我叫*<em><strong>，山西</strong></em>人，今年毕业于太原理工大学、数据科学与大数据技术专业，考取到西安电子科技大学的研究生，预计九月份开学。</li><li>我在校期间学习成绩良好，绩点排名在全专业前30%，通过了四六级考试，利用课余时间以及寒暑假参加了一系列科技竞赛与创新创业的竞赛，获得了优秀的成绩，包括挑战杯的全国银奖、互联网+的山西省金奖以及建模竞赛的山西省一等奖，这个竞赛的选题是当年的C题，也是关于银行贷款风险评估的。除了这些竞赛，也获得了一些在校的荣誉，比如校级的优秀共青团员、担任班长获得了优秀班干部的荣誉称号、疫情期间参加志愿活动获得了志愿服务奖学金，由于综合表现优异，毕业时获得了优秀毕业生的荣誉称号。</li><li>在大学期间主要学了C语言、python、数据分析挖掘、数据库、机器学习、深度学习的一些内容。</li><li>我是一个开朗热情的人，喜欢结交朋友、喜欢跑步、打羽毛球，平时也喜欢写一些东西，我大学期间做过微信公众号，然后毕业的这段时间搭建了自己的博客，分享学习到的东西。</li><li>这就是我的主要情况，我的自我介绍完毕，谢谢各位面试官。</li></ul><h3 id="2-你学了那些技术，对本岗位有所帮助"><a href="#2-你学了那些技术，对本岗位有所帮助" class="headerlink" title="2.你学了那些技术，对本岗位有所帮助"></a>2.你学了那些技术，对本岗位有所帮助</h3><ul><li>首先我学过数据库，可以对银行的一些客户数据、金融数据进行保管与相关操作</li><li>然后我学数据挖掘，可以根据用户信息对潜在用户进性挖掘预测，也可以分析用户的贷款风险</li><li>然后我还学过人工智能方面的知识，比如可以尝试着去做客服机器人，智能应答这种。</li><li>最后呢，我还会一些django和前端，可以搭建宣传网站之类的。</li></ul><h3 id="3-对建行的认识与理解"><a href="#3-对建行的认识与理解" class="headerlink" title="3.对建行的认识与理解"></a>3.对建行的认识与理解</h3><ul><li>中国建设银行，前身为成立于1954年10月1日的中国人民建设银行（后于1996年3月26日正式更名为中国建设银行），是中央管理的国有大型商业银行。主要经营领域包括公司银行业务、个人银行业务和资金业务。在境内有38家分行，在境外29个国家和地区设有分支机构及子公司，拥有基金、租赁、信托、人寿、财险、投行、期货、养老金等多个行业的子公司。</li></ul><h3 id="4-为什么想来银行工作"><a href="#4-为什么想来银行工作" class="headerlink" title="4.为什么想来银行工作"></a>4.为什么想来银行工作</h3><ul><li>首先银行这个岗位与自己所学的专业是比较契合的。</li><li>然后我认为银行能够为自己提供一个稳定的职业发展环境，这样就能够一心一意地把全部精力和注意力放在提升个人业务水平上，能够更快地得到持续性地成长，且有机会在一个领域内深耕。</li></ul><h3 id="5-谈谈你的缺点"><a href="#5-谈谈你的缺点" class="headerlink" title="5.谈谈你的缺点"></a>5.谈谈你的缺点</h3><ul><li>我的公开演讲能力比较差，在公共场合讲话的时候我会感到紧张，不过谈论我熟悉的领域我会比较放松。所以当我需要做公开发言的时候， 我必须要准备得很充分。我确实羡慕那些无论什么话题都能够高谈阔论的人。</li><li>还有一点就是自己独立思考的能力还比较弱，有时候会受别人的一些干扰，改变自己的思路，但时候往往发现自己是对的。所以说现在也在读一些书籍，慢慢的去改变这个毛病。</li></ul><h3 id="6-在学校做过什么实践活动"><a href="#6-在学校做过什么实践活动" class="headerlink" title="6.在学校做过什么实践活动"></a>6.在学校做过什么实践活动</h3><ul><li>首先，我在学校是单人的班长，管理班级事务，配合学院组织一些活动</li><li>然后我主要参加了一些竞赛，刚刚自我介绍也说过，这里不再赘述</li><li>我还参加一些志愿服务活动</li><li>有个遗憾的是没有参加学校的三下乡的活动，然后看见建行会组织类似活动，所以挺动心的。</li></ul><h3 id="7-金融科技的理解"><a href="#7-金融科技的理解" class="headerlink" title="7.金融科技的理解"></a>7.金融科技的理解</h3><ul><li>金融科技英译为Fintech， 是 Financial Technology 的缩写，是基于大数据、云计算、人工智能、区块链等一系列技术创新，全面应用于支付清算、借贷融资、财富管理、零售银行、保险、交易结算等六大金融领域，是金融业未来的主流趋势。能够提高效率、降低运营的成本。</li></ul><h3 id="8-印象深刻的事情"><a href="#8-印象深刻的事情" class="headerlink" title="8.印象深刻的事情"></a>8.印象深刻的事情</h3><ul><li>考研这段经历让我印象深刻，他不像在高中一样，有一起努力的伙伴、有监督的老师。真的就是孤军奋战，需要自己给自己做规划、自己监督自己、在这段时间，一直都很自律，也顺利的考上了心仪的学校，所以印象还是很深刻的。</li></ul><h3 id="9-对大数据的看法"><a href="#9-对大数据的看法" class="headerlink" title="9.对大数据的看法"></a>9.对大数据的看法</h3><ul><li>我感觉大数据是人类社会发展的大趋势，最早的提出者麦肯锡，大数据并非是想象上简单的对海量数据进行整理、收集，它的实质是通过收集、整理海量数据，利用布式运算，对个人、群体或行业领域的未来发展进行合理的精准的预测。大数据的四性：大规模性(Volume)、高速性(Velocity)、多样性(Variety)、价值性(Value)</li></ul><h3 id="10-生活中遇到烦恼和压力的时候如何排解？"><a href="#10-生活中遇到烦恼和压力的时候如何排解？" class="headerlink" title="10.生活中遇到烦恼和压力的时候如何排解？"></a>10.生活中遇到烦恼和压力的时候如何排解？</h3><ul><li>首先，我再大学期间结交了几个很要好的朋友，我压力大的时候会找他们倾诉，然后听听他们作为旁观者的意见。</li><li>然后我会去跑步，释放自己的压力</li></ul><h3 id="11-来我们银行可以做什么？"><a href="#11-来我们银行可以做什么？" class="headerlink" title="11.来我们银行可以做什么？"></a>11.来我们银行可以做什么？</h3><ul><li>答：通过我的研究领域可以在银行做金融科技相关工作，例如通过AI技术研发智能投资顾问与聊天机器人、股票价格预测、评估消费者行为和支付意愿、信用评分、保险业的承保与理赔、风险管理与压力测试、金融监管与识别监测等金融领域的问题；第二点还可以通过大数据金融利用互联网技术和信息通信技术，探索资金融通、支付、投资和信息中介的新型金融业务模式的研发。并通过数据分析与可视化来展示相应的分析结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA学习2：相关软件安装</title>
    <link href="/2022/06/30/08FPGA%E5%AD%A6%E4%B9%A02%EF%BC%9A%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2022/06/30/08FPGA%E5%AD%A6%E4%B9%A02%EF%BC%9A%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 引言<p>前前后后耗时三天，终于将用到的quartus、器件库、modelsim软件下载、破解、关联配置做好了。一路上碰到了各种奇奇怪怪的问题，有一点点地查找解决方案，现在把踩过的坑，以及找好的安装包分享到这里，便于自己以后使用，也给大家提供便捷。</p><p>首先要清楚quartus和modelsim分别是干什么的，Quartus是开发软件，可以进行项目开发、Verilog代码的编写等，就像是写Python所使用的pycharm；Modelsim是仿真软件，仿真顾名思义，就是将实际的工作电路模拟出来，可以方便查看输出等结果是否正确。</p><p>主要参考的教程是野火出品的这个视频，它的网址如下，但是其中没有具体说明软件的下载地址与破解方法，会遇到的常见问题也没有进行说明。<a href="https://www.bilibili.com/video/BV17z411i7er?p=3&vd_source=efae70b1a755d9c960b4d6e78ad98612">【野火】FPGA系列教学视频，真正的手把手教学，“波形图”教学法，现场画波形图写代码，硬件基于野火FPGA EP4CE10征途系列开发板，已完结_哔哩哔哩_bilibili</a></p><h2 id="一、quartus下载与破解"><a href="#一、quartus下载与破解" class="headerlink" title="一、quartus下载与破解"></a>一、quartus下载与破解</h2><p>quartus的下载地址为：<a href="https://www.jb51.net/softs/545630.html">quartus ii 13.0破解版下载 quartus ii(PLD&#x2F;FPGA开发软件) 13.0 免费特别版(附注册机) 下载-脚本之家 (jb51.net)</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750805365-ed2965b0-85ea-47ad-8d48-85f64d893940.png#clientId=u36f59fbd-45b1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=u67050f86&name=image.png&originHeight=348&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236290&status=done&style=none&taskId=ud108ce28-16ee-4e54-9fc1-ebd0a4037d3&title=&width=704" alt="image.png"></p><p>在这个网盘中下载下来之后会带有破解器，该网页也有破解的具体操作，这里不做过多的讲解，这一步遇到的坑:</p><ol><li>一定要将该软件安装在全英文路径，如果有中文路径的话会出现软件打不开的情况。</li><li>破解的原理可能与电脑的网卡有关，在电脑有多个网卡或者有虚拟网卡时会有多个NIC(ID)，这时候复制第一个就可以。</li></ol><p>破解完如何查看是否破解成功：</p><ol><li>在进入软件的时候，没有出现相关提醒</li><li>在license setup中可以看到到期的日期为2035年 ![]<img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750820639-1a16af20-4cae-44d7-89ad-875b971a0ad2.png#clientId=u36f59fbd-45b1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=625&id=ud16718a9&name=image.png&originHeight=820&originWidth=846&originalType=binary&ratio=1&rotation=0&showTitle=false&size=228128&status=done&style=none&taskId=u90bddced-ff94-4a07-87a7-9bdd1062b80&title=&width=644.5714285714286" alt="image.png"></li></ol><h2 id="二、quartus器件库的下载"><a href="#二、quartus器件库的下载" class="headerlink" title="二、quartus器件库的下载"></a>二、quartus器件库的下载</h2><p>器件库的安装可以参考这篇文章：<a href="https://blog.csdn.net/sou_nuo/article/details/117092405">Quartus II 13.0 添加器件库教程(包含下载地址)_阿聍的博客-CSDN博客_quartus器件库下载</a></p><p>但是一定要注意，不能用里面提供下载的器件库，因为器件库的版本必须与quartus完全一致，这里我就踩过坑，虽然版本都是13.0，但在这后面还有几位是不一致的，所以在网上找了很久才下载下来合适的器件库版本，下载地址如下：</p><p>链接：<a href="https://pan.baidu.com/s/1yIKSO0cfoZ0eYESn3lhv-g">https://pan.baidu.com/s/1yIKSO0cfoZ0eYESn3lhv-g</a>   提取码：ucm3</p><p>还有一点可能遇到的问题，就是教程里安装器件库的程序是从这个地方打开的</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750840330-c6d69089-fb41-4e26-8268-fbc5ac19a5ca.png#clientId=u36f59fbd-45b1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=624&id=uc06c5fab&name=image.png&originHeight=819&originWidth=444&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206242&status=done&style=none&taskId=u3975d07d-0c8e-4817-9724-f1fecb190ca&title=&width=338.2857142857143" alt="image.png"></p><h2 id="三、modelsim的下载与破解"><a href="#三、modelsim的下载与破解" class="headerlink" title="三、modelsim的下载与破解"></a>三、modelsim的下载与破解</h2><p>modelsim的下载地址如下：[modelsim se 10.5破解版下载_HDL语言仿真软件 v2020.5<a href="https://www.xiazai99.com/down/soft159256.html">网盘资源] - 99下载站 (xiazai99.com)</a></p><p>同样，在这个文章中也说明了破解的方法，但是如果按其操作，会出现各种错误，这部分错误的解决也是我花费时间最多的地方。</p><ol><li>在安装modelsim的过程中，不要一直选择是或者next，在其中有一步让选择是否安装相关驱动，一定要选择否，不然电脑就会蓝屏。这是血的教训。</li><li>如果按照教程的破解方法处理完毕，还是没有成功，很可能还是网卡有多个原因，这时可以直接将电脑的WiFi关掉，在进行破解</li><li>破解之后首次打开要使用管理员身份。</li></ol><h2 id="四、quartus与modelsim相关联"><a href="#四、quartus与modelsim相关联" class="headerlink" title="四、quartus与modelsim相关联"></a>四、quartus与modelsim相关联</h2><p>这一操作在引言部分的野火教程中有，但是按其操作还是会出现问题（但首先还是得先按着里面的操作一遍）。</p><ol><li><p>这个教程里跳过了新建项目，编写Verilog代码的步骤，直接进行仿真测试，我们没有相关程序的话是没发测试的，所以也要先建项目，写代码，这里看可以参考这个文章:<a href="https://blog.csdn.net/qq_37424623/article/details/123207484">Quartus软件创建第一个工程_驽马同学的博客-CSDN博客_quartus 创建工程</a>。但是这里面的代码又只展示了一半，还是图片，作为新手，完全不懂，无法操作，所以找了一段简单的代码，替换掉这篇文章中的Verilog进行测试，代码如下：  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown">`timescale  1ns/1ns<br>///////////////////////////////////////////////////////////////////////////<br>// Author        : EmbedFire<br>// Create Date   : 2019/03/12<br>// Module Name   : led<br>// Project Name  : led<br>// Target Devices: Altera EP4CE10F17C8N<br>// Tool Versions : Quartus 13.0<br>// Description   : 按键控制LED灯<br>//<br>// Revision      : V1.0<br>// Additional Comments:<br>// <br>// 实验平台: 野火<span class="hljs-emphasis">_征途Pro_</span>FPGA开发板<br>// 公司    : http://www.embedfire.com<br>// 论坛    : http://www.firebbs.cn<br>// 淘宝    : https://fire-stm32.taobao.com<br>//////////////////////////////////////////////////////////////////////////<br><br><br>module  myled<br>(<br><span class="hljs-code">    input   wire    key_in  ,   //输入按键</span><br><span class="hljs-code"></span><br><br><span class="hljs-code">    output  wire    led_out     //输出控制led灯</span><br><span class="hljs-code">);</span><br><span class="hljs-code"></span><br><br>//<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>//<br>//<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">* Main Code <span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>//</span><br><span class="hljs-emphasis">//<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>//</span><br><span class="hljs-emphasis">//led_out:led灯输出的结果为key_in按键的输入值</span><br><span class="hljs-emphasis">assign  led_out = key_in;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">endmodule</span><br></code></pre></td></tr></table></figure></li><li><p>在替换了上面的代码之后，新的问题出现，quartus无法分析成功，因为命名的问题，因为代码中主程序名还有文件名、以及项目名有一定的关系，把它们几个全设置为myled就可以成功。</p></li><li><p>在分析成功之后，点击仿真，按理说就应该打开modelsim软件了，但是可能并没有打开，而是报错，这是有可能是没有把默认的仿真软件设置为modelsim，在这里可以设置  <img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750851597-90d0c89a-e2af-495a-93ed-02395b5b7528.png#clientId=u36f59fbd-45b1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=595&id=u253d0dbf&name=image.png&originHeight=781&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&size=300364&status=done&style=none&taskId=ubd8eb30f-26b4-42bb-8632-c91e71bee8f&title=&width=724.5714285714286" alt="image.png"> </p></li><li><p>点击仿真后，modelsim的图标出现，却又再次提醒没有激活，但是单独打开modelsim是已经破解了正常打开的，这时有可能是quartus和modelsim两个破解过程中的使用的NIC(ID)不一样，把二者改为一样应该可以解决这个问题。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>磨刀不误砍柴工，学习FPGA之前，把这些必要的软件设置舒服是很重要的。之前在上学时也安装下载过许多的软件，这几个是遇到过流程最麻烦的，可能也是不熟悉的原因，花了几天时间，还是挺有成就感的，终于可以开始正式的学习了。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目申请书-书写经验总结</title>
    <link href="/2022/06/28/07%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B9%A6-%E4%B9%A6%E5%86%99%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/28/07%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B9%A6-%E4%B9%A6%E5%86%99%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />> 最近段时间在帮老师写项目申请书。第一次写，遇到了不少问题，在这里记录一下，写一点经验与心得，方便之后的再次书写。<h2 id="一、内容板块"><a href="#一、内容板块" class="headerlink" title="一、内容板块"></a>一、内容板块</h2><p>本次的项目申请书的主题是芯片缺陷检测。按照研究所给出的书写模板，主要分为九个主要版块</p><ol><li><p>项目的基本信息</p></li><li><p>项目负责人及主要成员</p></li><li><p><strong>项目的基本情况</strong></p><p>项目的研究背景、研究目标、研究意义、国内外研究现状、本项目研究成果的重要性和应用前景</p></li><li><p><strong>主要研究内容和目标</strong></p><p>项目的研究内容、研究方案、技术路线、关键技术、创新点</p></li><li><p>项目负责人及团队信息</p></li><li><p>研究基础和团队代表性研究成果</p></li><li><p><strong>项目实施进度计划</strong></p></li><li><p>预期成果</p></li><li><p><strong>社会效益与风险评估</strong></p></li></ol><p>在这九个主要的板块之中加黑的部分，也就是：<strong>3.项目的基本情况、4.主要研究内容和目标、7.项目实施进度计划、9.社会效益与风险评估</strong> 是主要的内容。其他几个部分填的都是一些相关的信息，可能就是填写几个表格。因此主要介绍一下这几块内容一个写法。</p><h2 id="二、书写技巧"><a href="#二、书写技巧" class="headerlink" title="二、书写技巧"></a>二、书写技巧</h2><p>在写项目书之前，通常会得到一个叫做“指南”的东西，这个里面说清楚了对方希望解决的问题还有希望达到的预期效果，比如本项目的指南，就说明了，想要用深度学习算法去完成芯片的缺陷检测，且列举了希望解决芯片缺陷中的哪些基本类型，并指明了要求是准确度达到95%以上。</p><p>所以各个部分都是围绕这些来写，也就是说，指南中的话反复出现在各个版块，且不要害怕重复。</p><h2 id="三、重点部分"><a href="#三、重点部分" class="headerlink" title="三、重点部分"></a>三、重点部分</h2><h3 id="1-项目的基本情况"><a href="#1-项目的基本情况" class="headerlink" title="1.项目的基本情况"></a>1.项目的基本情况</h3><ul><li>研究背景及意义。（研究背景和意义经常放一块去说，所以就可以归为一个小标题）<ul><li>首先芯片是什么，它在哪些方面广泛应用，有什么重要性和必要性。然后说《国家相关战略支持》对该产业的支持；</li><li>然后引到芯片缺陷检测方面，说一下为什么要进行芯片缺陷检测，指明这项任务的意义；</li><li>现有的芯片检测方法有哪些缺陷与不足，如果不改变会有什么后果；</li><li>引出当今机器视觉技术和深度学习技术的当今发展趋势，这项技术有什么优点。一些国外大公司已经开始布局。</li><li>使用深度学习进行芯片检测的意义：对国家、对产业、对落实某项国家政策。</li></ul></li><li>研究目标<ul><li>先用一句话概述：针对什么问题、利用&#x2F;基于什么技术优势、开发什么东西。</li><li>然后围绕着指南中的内容。算法要能解决哪些问题、应该具备什么样的特性（比如鲁棒性、可进化等）、准确度要达到什么程度。</li><li>还要超出指南，提出一些新的东西，比如本文讲算法部署到智能硬件。</li></ul></li><li>国内外研究现状<ul><li>搜集在芯片缺陷检测领域的相关文章，最好对不同的方法进行分类与归纳</li><li>最后要“综上所述”，概括出现有技术的问题，强调本项目研究的先进性与合理性。</li><li>记得要把引用的文献也写上。</li></ul></li></ul><h3 id="2-重要性与应用前景"><a href="#2-重要性与应用前景" class="headerlink" title="2.重要性与应用前景"></a>2.重要性与应用前景</h3><ul><li>“没我不行”。芯片缺陷检测很重要但国内技术落后。如果继续利用传统方法造成什么后果</li><li>“有我更好”。说一下用到的技术，这些技术有什么优势，用了之后可以解决指南中的那些问题。</li><li>应用前景，先简单提及背景：芯片产业很大，芯片缺陷的质检环节比不可少，有很大的应用前景。</li></ul><h3 id="3-研究内容和目标"><a href="#3-研究内容和目标" class="headerlink" title="3.研究内容和目标"></a>3.研究内容和目标</h3><ul><li>研究内容<ul><li>围绕着“指南”，将要解决的问题或者说要做的事，分为几个层级。每一个层级就是一个研究内容，这几个研究内容之间既相互独立又一脉相承，可以通过一个示意图先画出来。需要注意的是，这里每个研究内容要起一个小标题，要专业且完整。</li><li>示意图：<img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750704814-fed50527-2312-444e-beef-d40a15a2f2f0.png#clientId=u241462fe-5d44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=378&id=u107e2a24&name=image.png&originHeight=496&originWidth=895&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162309&status=done&style=none&taskId=udf3cab9e-d911-455e-af02-4dfd973c2bb&title=&width=681.9047619047619" alt="image.png"></li><li>然后在示意图下面，每一个内容描述一段话，并不涉及到具体技术，就是简单论述研究什么内容，算是对示意图的一个展开。</li></ul></li><li>研究方案<ul><li>研究方案也不是具体的内容，首先也是画一张图，讲清楚研究的步骤，对于每个研究内容，先做什么、后做什么</li><li>示意图：<img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750731174-9e24b0c1-3aff-423b-8947-032d73e8e805.png#clientId=u241462fe-5d44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=620&id=uba2bab38&name=image.png&originHeight=814&originWidth=627&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188594&status=done&style=none&taskId=u05d96eba-fa3e-47da-b2d5-eb6c34fa515&title=&width=477.7142857142857" alt="image.png"></li><li>然后再用语句详细的描述步骤</li></ul></li><li>技术路线<ul><li>这里就需要写每一部分的详细技术了，比如对于数据集的准备，要对数据集的数量、专家标注、用到的图像处理技术展开写，以及展示具体的芯片缺陷图片。对于用到的算法，就需要将结构、公示等都写上。</li><li>还是可以根据研究内容去分点写。</li></ul></li><li>关键技术和创新点<ul><li>因为纯写创新内容并不好写，所以这里可以分为：拟解决的关键问题、主要创新点。</li><li>这里的主要创新点就不一定非要是创新，就可以对应的写 如何去解决那些关键问题，当然最好还是展示出创新。 比如你既觉得关键问题是：目标检测算法的优化。那么对应的创新点就是：针对微小芯片缺陷检测的检测算法优化。这里面不用写太多具体技术，那些公式、算法的大头还是放在技术路线里面。</li></ul></li></ul><h3 id="3-项目的实施进度"><a href="#3-项目的实施进度" class="headerlink" title="3.项目的实施进度"></a>3.项目的实施进度</h3><p>这一部分根据协商好的时间，将过程按照半年来分，把研究的内容分号，然后对于每一部分，再写一些具体研究的步骤就可以。</p><h3 id="4-社会效益与风险评估"><a href="#4-社会效益与风险评估" class="headerlink" title="4.社会效益与风险评估"></a>4.社会效益与风险评估</h3><ul><li>对于社会效益。主要就是项目实施之后对社会能起到的积极的作用。主要的方面有：促进经济发展、促进社会进步、带动就业、提高企业的产能与质量、提高人民生活水平之类的，就往里面套着写。</li><li>风险评估分为几个版块：技术风险、商业风险、管理风险，还有风险如何规避。对于风险，都要落脚在风险较小之上。<ul><li>技术风险。对于关键技术、本单位进行了深入理论研究、关键技术进行了大量实验、证明可行。本单位致力于研究什么、有资质。得出结论：基本无风险和不确定因素。</li><li>管理风险。本项目承担单位，——机构承担过多项国家级重点项目的管理与实施，具有很好的项目管理措施和经验，在管理上无风险。</li><li>商业风险。国产率上看，中国—–比重不断提升。中国—–国产化率提升，市场规模有较大的发展空间。因此，本项目的市场前景非常广阔。</li><li>规避风险的主要措施。对实验室和学校的情况进行介绍。对该行业之前有所涉及与研究。对关键技术进行了论证之类的。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章根据对几天书写项目书的经验进行了总结。主要展示了项目书分为那些版块，每个版块主要写些什么内容。虽然可能并不适用于各类项目申请书的书写，但是也算是有了一个大致了解，不至于上手后不知道要干什么、不知道要查找哪些</p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FocusNote快捷操作</title>
    <link href="/2022/06/28/06FocusNote%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/06/28/06FocusNote%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />> 现在写博客的顺序是：现在FocusNote（专注笔记）上写好，然后复制到typora上，之后再写到博客相应的markdown文档中。<p>FocusNote是国产的笔记软件，界面很好看，书写也很方便，写一些复盘或者总结资料都在这个上面，在几年前也买下了永久版本。因此在这里简单记录一下常用的快捷方式，之后就不用经常跑官网去找了。</p><p><strong>段落相关：</strong></p><table><thead><tr><th align="center">标题</th><th align="center">Ctrl+alt+1&#x2F;2&#x2F;3</th></tr></thead><tbody><tr><td align="center">清除标题</td><td align="center">Ctrl+alt+0</td></tr><tr><td align="center">有序列表</td><td align="center">Ctrl+shift+i</td></tr><tr><td align="center">无序列表</td><td align="center">Ctrl+shift+u</td></tr><tr><td align="center">待办事宜</td><td align="center">Ctrl+shift+y</td></tr><tr><td align="center">引用</td><td align="center">Ctrl+shift+q</td></tr><tr><td align="center">代码块</td><td align="center">Ctrl+shift+c</td></tr><tr><td align="center">链接</td><td align="center">Ctrl+l</td></tr><tr><td align="center">公式</td><td align="center">Ctrl+alt+c</td></tr><tr><td align="center">附件</td><td align="center">Ctrl+alt+f</td></tr></tbody></table><p><strong>字体相关：</strong></p><table><thead><tr><th align="center">加粗</th><th align="center">Ctrl+b</th></tr></thead><tbody><tr><td align="center">斜体</td><td align="center">Ctrl+i</td></tr><tr><td align="center">下划线</td><td align="center">Ctrl+u</td></tr><tr><td align="center">中划线</td><td align="center">Ctrl+t</td></tr><tr><td align="center">高亮</td><td align="center">Ctrl+1&#x2F;2…&#x2F;9</td></tr><tr><td align="center">清除高亮</td><td align="center">Ctrl+0</td></tr></tbody></table><p><strong>页面相关：</strong></p><table><thead><tr><th align="center">查看页面信息</th><th align="center">alt+ctrl+l</th></tr></thead><tbody><tr><td align="center">打开大纲</td><td align="center">alt+ctrl+o</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>各类教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专注笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA学习1：初始FPGA</title>
    <link href="/2022/06/20/05FPGA%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%88%9D%E5%A7%8BFPGA/"/>
    <url>/2022/06/20/05FPGA%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%88%9D%E5%A7%8BFPGA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 1 FPGA是什么<p>​FPGA(Field Programmable Gate Array,简称FPGA)，<strong>现场可编程</strong>门阵列，一种以数字电路为主的集成芯片，属于可编程逻辑器件PLD（Programmable Logic Device)的一种。</p><h3 id="FPGA的分类"><a href="#FPGA的分类" class="headerlink" title="FPGA的分类"></a><strong>FPGA的分类</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750559990-9a0d9775-2cb6-4823-acf7-1c785e34566d.png#clientId=u194feb0d-a974-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=u3c63d900&name=image.png&originHeight=296&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166931&status=done&style=none&taskId=ubdb33b0e-c9c8-4bbb-9ac3-2576512a064&title=&width=502.85714285714283" alt="image.png"></p><h3 id="FPGA工作原理"><a href="#FPGA工作原理" class="headerlink" title="FPGA工作原理"></a><strong>FPGA工作原理</strong></h3><p>​FPGA是可以通过编程<strong>改变芯片内部电路结构</strong>，以此来满足不同硬件产品的应用需求。FPGA可编程跟软件编程有着本质的区别，对于CPU或者单片机的编程，往往是通过改变上面的寄存器的配置来实现的，但是并不会改变这个芯片的逻辑功能，但FPGA是确确实实把芯片内部的电路改变了，比如，上图分类中的第二种叫反熔丝技术，熔丝就是将电路烧断，而反熔丝就是将烧断的电路在连接起来。</p><p>​并不能通过软件编程，让一枚图形处理芯片编程为一枚通信芯片，FPGA则可以。FPGA的可编程性，叫硬件可编程。他让FPGA可以从逻辑门阵列进行编程，从而使FPGA可以在逻辑电路层面上改变。</p><p>​上面是比较直观的理解，接下来给出学术上的原理解释：</p><p>​FPGA采用了逻辑单元阵列LCA（Logic Cell Array）这样一个概念，内部包括可配置逻辑模块CLB（Configurable Logic Block）、输入输出模块IOB（Input Output Block）和内部连线（Interconnect）三个部分。 现场可编程门阵列（FPGA）是可编程器件，与传统逻辑电路和门阵列（如PAL，GAL及CPLD器件）相比，FPGA具有不同的结构。FPGA利用小型查找表（16×1RAM）来实现组合逻辑，每个查找表连接到一个D触发器的输入端，触发器再来驱动其他逻辑电路或驱动I&#x2F;O，由此构成了既可实现组合逻辑功能又可实现时序逻辑功能的基本逻辑单元模块，这些模块间利用金属连线互相连接或连接到I&#x2F;O模块。FPGA的逻辑是通过向内部静态存储单元加载编程数据来实现的，存储在存储器单元中的值决定了逻辑单元的逻辑功能以及各模块之间或模块与I&#x2F;O间的联接方式，并最终决定了FPGA所能实现的功能，FPGA允许无限次的编程。</p><h3 id="“现场可编程”特性"><a href="#“现场可编程”特性" class="headerlink" title="“现场可编程”特性"></a><strong>“现场可编程”特性</strong></h3><p>​FPGA可以在现场完成编程，而不需要把芯片拆下来，或是送回厂商来完成这个编程的操作，可通过远程或本地完成真正意义上的实时编程。</p><h2 id="2-FPGA的优势"><a href="#2-FPGA的优势" class="headerlink" title="2 FPGA的优势"></a><strong>2 FPGA的优势</strong></h2><p>​FPGA可以实现任意电路组合，我们可以把FPGA看成是一堆乐高，根据需要既可以组成非常简单的模型，也可以组合出非常复杂的模型。这就使得FPGA具备高度的灵活性。</p><p>​因为FPGA是通过逻辑电路来实现功能的，所以它的算力非常强，同时功耗非常低。因此很多人称它成为“芯片之王”。目前在很多行业被广泛使用。</p><p>总结，FPGA的优势：</p><p>1、编程灵活，开发周期短（可以替代ASIC）；</p><p>2、并发处理，速度非常快；</p><p>3、功耗低；</p><p>4、FPGA技术趋于成熟，成本已经和ASIC相当。</p><h2 id="3-FPGA的应用方向"><a href="#3-FPGA的应用方向" class="headerlink" title="3 FPGA的应用方向"></a>3 FPGA的应用方向</h2><ol><li>通信领域<ul><li>低延时 高效率</li><li>产品快速开发 各种协议的切换</li></ul></li><li>视频图像处理<ul><li>最高的实时性</li></ul></li><li>人工智能<ul><li>加速深度学习</li></ul></li><li>汽车驾驶<ul><li>低延时</li></ul></li></ol><h2 id="4-产业现状"><a href="#4-产业现状" class="headerlink" title="4 产业现状"></a>4 产业现状</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750535779-1b383c83-cacc-442b-9f2e-72a5980a474e.png#clientId=u194feb0d-a974-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=ue1421cac&name=image.png&originHeight=371&originWidth=801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173730&status=done&style=none&taskId=u7bf320cc-af51-421a-bb3f-99c17b18693&title=&width=610.2857142857143" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750543785-19099077-2ce0-4263-a078-aca86ca6cc73.png#clientId=u194feb0d-a974-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=u6764d9f4&name=image.png&originHeight=412&originWidth=785&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126887&status=done&style=none&taskId=u80e370b6-f687-4f17-9e25-3c632eefe7d&title=&width=598.0952380952381" alt="image.png"></p><p>​国外的赛灵思比较厉害，是巨头</p><p>​国内普遍性能落后一些</p>]]></content>
    
    
    <categories>
      
      <category>FPGA学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图床搭建</title>
    <link href="/2022/06/17/04Markdown%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86--%E5%9B%BE%E5%BA%8A%E4%B8%8E%E8%BD%AC%E7%A0%81/"/>
    <url>/2022/06/17/04Markdown%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86--%E5%9B%BE%E5%BA%8A%E4%B8%8E%E8%BD%AC%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 一、图床<h3 id="1-图床介绍"><a href="#1-图床介绍" class="headerlink" title="1 图床介绍"></a>1 图床介绍</h3><p>对于不写博客的伙伴，图床可能是一个陌生的词汇。从名字来看，应该和存储图片有关，但为什么要叫做“床”呢？</p><p>图床其实是互联网上进行图片存储的空间。因为博客往往是以markdown的形式发布，而markdown不同于平时编辑的word文档，它其中显示的图片并不是嵌入在文件中，而是引用外部的源。语法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(这里写图片在本服务器或本计算机的存储地址，或者网上图片的网址)<br></code></pre></td></tr></table></figure><p>这样以来，就会出现两个问题：</p><ol><li>如果是引用存储在本地的图片<ul><li>图片的路径不容易写对</li><li>如果误将本地的图片删除，那么博客中就会报错</li></ul></li><li>如果随便引用一个网上的图片<ul><li>这个图片可能随时会被作者删除或者其他原消失</li></ul></li></ol><p>在这种情况下，自己在网络上开辟一个安全可靠的网络空间就很重要。本文就记录一下图床的搭建与使用。</p><h3 id="2-图床搭建"><a href="#2-图床搭建" class="headerlink" title="2 图床搭建"></a>2 图床搭建</h3><p>github、Gitee、阿里云等都可以开辟空间上传图片，所以本身就具备了作为图床的能力，我们就可以利用这些免费的空间来搭建图床。然而每次手动上传操作时比较困难的，这是出现了一个图床的管理工具叫picgo，这是一个免费开源的工具。界面如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750310286-2f68bbb9-2ddf-46fb-a81d-5ba05476ea10.png#clientId=ufcc7160c-3d9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=u692e3567&name=image.png&originHeight=423&originWidth=758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85490&status=done&style=none&taskId=u0c240480-b07e-4e03-8d20-f99edb6f6f5&title=&width=577.5238095238095" alt="image.png"></p><p>配置好连接后，将图片拖到虚线框中就可以方便的上传到图床空间，实现的机制就是token验证。</p><p>建立连接的方法也很简单，在picgo的官方文档就给出了详细的教程（包含github、七牛图库、阿里云OSS都有）：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">配置手册 | PicGo</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750320674-dbb881cc-53e3-4484-9eff-ac8b2f224815.png#clientId=ufcc7160c-3d9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=293&id=u9a348ddb&name=image.png&originHeight=385&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95113&status=done&style=none&taskId=udab860cd-e9d6-442f-82e1-c6ba9cb2ef9&title=&width=591.2380952380952" alt="image.png"></p><p>如果在配置过程中有疑问可以观看这个B站视频<a href="https://www.bilibili.com/video/BV1Lt411J7Mp?spm_id_from=333.337.search-card.all.click">PicGo五分钟打造你的私人图床（稳定、快速、免费）_哔哩哔哩_bilibili</a></p><p>这是SMMS图床上传后的界面：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750328084-4f3d129a-518d-4537-8ce4-5ca0da627003.png#clientId=ufcc7160c-3d9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=195&id=u3042c5f5&name=image.png&originHeight=256&originWidth=760&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39316&status=done&style=none&taskId=u73750f69-6526-4188-ac57-eae3c1d9564&title=&width=579.047619047619" alt="image.png"></p><h2 id="二、转码"><a href="#二、转码" class="headerlink" title="二、转码"></a>二、转码</h2><p>这个方法简单粗暴，就是将图片转换为一段代码，就可以将其以文字的形式嵌入markdown文档</p><h3 id="1-通过在线网站"><a href="#1-通过在线网站" class="headerlink" title="1 通过在线网站"></a>1 通过在线网站</h3><p><a href="http://www.jsons.cn/img2base64">图片在线转换base64编码-在线base64编码转换成图片工具 (jsons.cn)</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750338047-16991d1b-be75-4141-b84d-8c041c929899.png#clientId=ufcc7160c-3d9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u8f82ce94&name=image.png&originHeight=371&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76946&status=done&style=none&taskId=udeb679af-3d94-405e-80a0-20fd65cc179&title=&width=597.3333333333334" alt="image.png"></p><h3 id="2-通过运行python代码"><a href="#2-通过运行python代码" class="headerlink" title="2 通过运行python代码"></a>2 通过运行python代码</h3><p>参考<a href="https://blog.csdn.net/weixin_35757704/article/details/123466261">python图片转base64编码，与base64编码转图片_呆萌的代Ma的博客-CSDN博客_python 图片base64编码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">img_to_base64</span>(<span class="hljs-params">image_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;图片转base64，返回byte类型&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(image_path, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> image_file:<br>        data = base64.b64encode(image_file.read())<br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">base64_to_img</span>(<span class="hljs-params">base64_data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;base64转图片&quot;&quot;&quot;</span><br>    source_image = Image.<span class="hljs-built_in">open</span>(BytesIO(base64.b64decode(base64_data)))<br>    source_image.show()  <span class="hljs-comment"># 展示图片</span><br>    <span class="hljs-keyword">return</span> source_image<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    base64_d = img_to_base64(<span class="hljs-string">&quot;this_img.png&quot;</span>)  <span class="hljs-comment"># 路径转base64</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;base64的值：&quot;</span>, base64_d.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)[:<span class="hljs-number">40</span>], <span class="hljs-string">&quot;....&quot;</span>)  <span class="hljs-comment"># 打印base64的前40个字符</span><br>    image = base64_to_img(base64_d)<br>    image.save(<span class="hljs-string">&quot;本地图片.png&quot;</span>)  <span class="hljs-comment"># 保存图片</span><br></code></pre></td></tr></table></figure><h3 id="3-通过typora"><a href="#3-通过typora" class="headerlink" title="3 通过typora"></a>3 通过typora</h3><p>刚刚发现将图片复制进typora后会自动转换。所以就可以实现一种操作：</p><p>先在word的工具上写好文档，然后整个复制到typora中，就生成了最终能上传的文档。</p><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4 缺点"></a>4 缺点</h3><p>图片的信息量很大，转换出来的编码也很长，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750349171-9f14e687-9f4f-4a20-a3a7-40df2b04bb70.png#clientId=ufcc7160c-3d9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=376&id=ue7f0251b&name=image.png&originHeight=493&originWidth=764&originalType=binary&ratio=1&rotation=0&showTitle=false&size=604955&status=done&style=none&taskId=u6adf80de-41a4-4bda-91b9-fbd4e2f8cb3&title=&width=582.0952380952381" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇总结了markdown中图片的处理方法，第一种是利用图床，方便快捷，但需要进行相关配置；第二种利用转码，可以将图片嵌入markdown文件，但是编码很长，很不美观。但是两种方法的操作都不困难。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最近发现从语雀中导出的markdown格式文件会自动将图片上传服务器并转为正确格式，但是hexo上传之后又显示不出来，有两种解决方法：<br>1.在markdown文件中加一条语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;meta name<span class="hljs-operator">=</span><span class="hljs-string">&quot;referrer&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;no-referrer&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>2.将每个图片的连接中从#client开始全部删掉就可以正常显示了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656760225647-19d20436-ff6c-43fa-9148-a05c0107d6ad.png#clientId=u17069117-dbbb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=88&id=u0d9f2693&name=image.png&originHeight=115&originWidth=1235&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49941&status=done&style=none&taskId=uf28d6af3-cdd6-4dd9-9710-3f46422516d&title=&width=940.952380952381" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>各类教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑远程控制</title>
    <link href="/2022/06/16/03%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/06/16/03%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />最近探索了两种远程控制的方法。> **第一种是用向日葵**，使用方法非常简单，只需要在ipad和电脑上都下载向日葵，输入相应的访问号后就能直接实现访问，连接速度、稳定性都很不错，不好的一点就是**交互性很差**，鼠标的邮右键和滚轮无法操作，这对于经常使用电脑已经习惯电脑操作的人几乎无法接受。所以以后可以单用向日葵来传输电脑上的文件。> **另一款软件是RDcient**，这个软件利用的是windows系统自己的远程访问功能，所以克服了不能使用邮件和滚轮的问题，所有的操作都和电脑一模一样，所以只要有个可以蓝牙连接ipad的键盘还有鼠标可以完美的实现远程办公。但是它的配置过程稍微复杂一些，而且还需要window是专业版（因为远程功能是专业版才会提供的。同时另一个致命问题是rdclient只能实现统一局域网下访问，但是有其他方法能实现外网的访问。<p>本文就来介绍RDclient的具体步骤（包括windows专业版激活、RDclient的配置以及如何实现外网访问）</p><h3 id="1-window专业版激活"><a href="#1-window专业版激活" class="headerlink" title="1. window专业版激活"></a><strong>1. window专业版激活</strong></h3><p>这个很简单，可以在百度上搜索相应的激活码，但是可能大多失效。可以去淘宝上买激活码，也就几块钱，商家也会给教程，教你一步步操作。</p><h3 id="2-RDclient配置"><a href="#2-RDclient配置" class="headerlink" title="2. RDclient配置"></a><strong>2. RDclient配置</strong></h3><p>在ipad应用中心下载软件。之后会让填写相应的用户信息：</p><ol><li>名称写为IP地址</li><li>用户名和密码是你登录windows时的微软账号密码</li><li>网关写为默认网关，网关界面中的用户还是选择之前设置好的微软账户</li><li>保存后即可实现访问</li></ol><p>ip地址和默认网关可以在电脑运行框中输入ifconfig现实。<br>运行框的唤起方法：：win+r 在小框中输入cmd<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656750133093-f388befe-16be-4562-a6f5-8b6e31e811ff.png#clientId=u7f180abb-9154-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=u95378e37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=760&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89834&status=done&style=none&taskId=u08800f33-8f04-47fd-9d89-ebb3253f60d&title=&width=579.047619047619" alt="image.png"></p><h3 id="3-实现外网访问"><a href="#3-实现外网访问" class="headerlink" title="3. 实现外网访问"></a><strong>3. 实现外网访问</strong></h3><p>实现外网访问的原理很简单：让外网伪装成局域网，可以用到一个软件叫蒲公英，在电脑上下载一个，在平板上下载一个，注册账号使其运行，两个地方使用同一账号登录后就会自动组网，变成虚拟的局域网，至于这个虚拟局域网的ip网址可以在蒲公英管理平台这个网页看到。（蒲公英的下载地址不好找，直接贴在这里<a href="https://pgy.oray.com/download/personal/#visitor">蒲公英软件客户端官方下载 - 贝锐蒲公英官网 (oray.com)</a>）<br>当知道虚拟ip后，再用ipconfig指令查看ipv4的地址，找到其中是虚拟ip的那个（两个很相似），然后查看对应的网关，知道这些信息后，就像之前配置RDclient的操作一边，再建立一个连接，这就实现了外网访问。（但要注意，ipad和电脑上的蒲公英必须保持运行的状态）</p>]]></content>
    
    
    <categories>
      
      <category>各类教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>电脑远程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法</title>
    <link href="/2022/06/13/02MarkDown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/13/02MarkDown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />>本篇文章记录一些Markdown的语法，为以后写博客做好准备。>参考学习文章：https://blog.csdn.net/u014061630/article/details/81359144<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章分为四部分内容：快捷键、基本语法、常用技巧、软件推荐。</p><h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl+B</td></tr><tr><td>斜体</td><td>Ctrl+I</td></tr><tr><td>引用</td><td>Ctrl + Q</td></tr><tr><td>插入链接</td><td>Ctrl + L</td></tr><tr><td>插入代码</td><td>Ctrl + K</td></tr><tr><td>插入图片</td><td>Ctrl + G</td></tr><tr><td>提升标题</td><td>Ctrl + H</td></tr><tr><td>有序列表</td><td>Ctrl + O</td></tr><tr><td>无序列表</td><td>Ctrl + U</td></tr><tr><td>横线</td><td>Ctrl + R</td></tr><tr><td>撤销</td><td>Ctrl + Z</td></tr><tr><td>重做</td><td>Ctrl + Y</td></tr></tbody></table><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h4 id="2-1-标题分级"><a href="#2-1-标题分级" class="headerlink" title="2.1 标题分级"></a>2.1 标题分级</h4><p><strong>共支持六级标题</strong></p><p>一级标题：# 一级</p><p>二级标题：## 二级</p><p>三级标题：### 三级</p><p>效果如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749553072-0659f39d-1e5e-46b4-a3bb-f32da38b1093.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=ubf2dc60e&name=image.png&originHeight=266&originWidth=240&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14782&status=done&style=none&taskId=udc8a66c0-7b2d-4cd6-a612-6be35f7c949&title=&width=182.85714285714286" alt="image.png"><br>（4-6级依次类推）</p><h4 id="2-2字体的斜体、粗体、删除线"><a href="#2-2字体的斜体、粗体、删除线" class="headerlink" title="2.2字体的斜体、粗体、删除线"></a>2.2字体的斜体、粗体、删除线</h4><p>倾斜1：*演示文字*</p><p>倾斜2：_演示文字_</p><p>加粗1：**演示文字**</p><p>倾斜加粗：***演示文字***</p><p>删除线：~~演示文字~~</p><p>效果如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749561236-b86afdea-6b13-4730-93c0-2e5aa01792fa.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=166&id=uc8c8e2ad&name=image.png&originHeight=218&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42608&status=done&style=none&taskId=ua64d4457-812f-4886-b3e5-6edcf67dfba&title=&width=210.28571428571428" alt="image.png"></p><h4 id="2-3代码块"><a href="#2-3代码块" class="headerlink" title="2.3代码块"></a>2.3代码块</h4><p>`&#96;&#96;<br>代码内容<br>import numpy as np<br>import pandas as pd<br>`&#96;&#96;</p><p>效果演示：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">代码内容：<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h4 id="2-4引用"><a href="#2-4引用" class="headerlink" title="2.4引用"></a>2.4引用</h4><p>&gt;引用1</p><p>&gt;&gt;引用2</p><p>&gt;&gt;&gt;引用3</p><p>效果演示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749569223-f4a7d832-2c3e-4a45-8c3b-16d01e23bf39.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=ubbaf4df3&name=image.png&originHeight=315&originWidth=237&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7297&status=done&style=none&taskId=u2efd95b2-6f58-48c0-9802-2ec3eedcc76&title=&width=180.57142857142858" alt="image.png"></p><p>还可进行嵌套：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749575354-0515b5aa-b6ba-4591-978e-7ce2f663cd4f.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=158&id=u8bdf516f&name=image.png&originHeight=207&originWidth=323&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6889&status=done&style=none&taskId=u12336552-60a7-477d-8e78-9287e4e0175&title=&width=246.0952380952381" alt="image.png"></p><h4 id="2-5有序列表与无需列表"><a href="#2-5有序列表与无需列表" class="headerlink" title="2.5有序列表与无需列表"></a>2.5有序列表与无需列表</h4><blockquote><p>无序列表</p></blockquote><p>- 第一行</p><p>- 第二行</p><p>- 第三行</p><p>（注意-后面必须加一个空格才能生效）</p><p>效果演示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749583241-5f3c2e7e-59f4-4cfd-96d7-1ddedfaeb3a9.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=uee907fe0&name=image.png&originHeight=170&originWidth=167&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9051&status=done&style=none&taskId=u5dde10d2-17f3-46c4-be46-90f7d1b7bae&title=&width=127.23809523809524" alt="image.png"></p><blockquote><p>有序列表</p></blockquote><p>1.(空格)第一行</p><p>2.(空格)第二行</p><p>3.(空格)第三行</p><p>效果演示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749590936-eb6669e7-1b78-4fa2-94a2-e4172cd4cfe9.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=125&id=u1eb580c5&name=image.png&originHeight=164&originWidth=188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9409&status=done&style=none&taskId=u7ee3e5cb-1dab-4ac1-90dd-2a933d578c6&title=&width=143.23809523809524" alt="image.png"></p><h4 id="2-6表格"><a href="#2-6表格" class="headerlink" title="2.6表格"></a>2.6表格</h4><blockquote><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</p></blockquote><p>|  表头    | 表头  |<br>|  - - - -  | - - - -  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p><p>效果演示：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h2 id="三、特殊用法"><a href="#三、特殊用法" class="headerlink" title="三、特殊用法"></a>三、特殊用法</h2><h4 id="3-1-想输出某个符号，不想让它作为语法标记符，使用-，-后面加的字符会显示出来"><a href="#3-1-想输出某个符号，不想让它作为语法标记符，使用-，-后面加的字符会显示出来" class="headerlink" title="3.1 想输出某个符号，不想让它作为语法标记符，使用\，\后面加的字符会显示出来"></a>3.1 想输出某个符号，不想让它作为语法标记符，使用\，\后面加的字符会显示出来</h4><h4 id="3-2-如果想更换字体"><a href="#3-2-如果想更换字体" class="headerlink" title="3.2 如果想更换字体"></a>3.2 如果想更换字体</h4> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span>&gt;</span>我是黑体字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;微软雅黑&quot;</span>&gt;</span>微软雅黑<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;楷体&quot;</span>&gt;</span>楷体<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果演示</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/11/kuangstudybcae9639-a98b-4dcd-86ce-3d2a40e1a51f.png#crop=0&crop=0&crop=1&crop=1&id=Q7UxV&originHeight=137&originWidth=174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h4 id="3-3-规定颜色和大小"><a href="#3-3-规定颜色和大小" class="headerlink" title="3.3 规定颜色和大小"></a>3.3 规定颜色和大小</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;font <span class="hljs-attribute">color</span>=#1157ff <span class="hljs-attribute">size</span>=4 <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;宋体&quot;</span>&gt;颜色为#11577ff，大小为4的宋体&lt;/font&gt;<br></code></pre></td></tr></table></figure><p>演示效果</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749604581-9f9b94ed-355f-4a34-af29-ba911cfa27ae.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=56&id=u70fb10a5&name=image.png&originHeight=73&originWidth=489&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11890&status=done&style=none&taskId=u5a06b5e7-6438-483a-a010-40a9272a603&title=&width=372.57142857142856" alt="image.png"></p><h2 id="四、软件推荐"><a href="#四、软件推荐" class="headerlink" title="四、软件推荐"></a>四、软件推荐</h2><p>Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/759833/1656749615115-f012e148-d1b7-444b-8a56-b72cebdc7c10.png#clientId=ueff216f1-536b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=119&id=ub064df53&name=image.png&originHeight=156&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17616&status=done&style=none&taskId=u1a1af3be-8d10-42e9-bd67-ab7838d18bc&title=&width=572.1904761904761" alt="image.png"><br>下载地址：<a href="https://www.typora.io/">https://www.typora.io/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍的是markdown的基础部分，除此之外还有能写出公式的latex语法以及绘制流程图的操作，这些知识以后有时间继续总结</p>]]></content>
    
    
    <categories>
      
      <category>各类教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的基本使用</title>
    <link href="/2022/06/12/01hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/06/12/01hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />这是第一篇文章，简单记录一下hexo发布文章、部署服务器等使用命令。<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span>   引号中写文章名称<br></code></pre></td></tr></table></figure><p>更多信息访问: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>更多信息访问: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate     这个命令可以简化为 hexo g<br></code></pre></td></tr></table></figure><p>更多信息访问: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到网站"><a href="#部署到网站" class="headerlink" title="部署到网站"></a>部署到网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy    这个命令可以简写为 hexo d<br></code></pre></td></tr></table></figure><p>更多信息访问: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给文章添加一个分类。</span><br>categories: 1<br><span class="hljs-comment"># 这会将文章分类1/2子分类目录下。</span><br>categories: [1, 2]<br><span class="hljs-comment">#多分类，文章被分类到123、456以及123的自分类789这3个分类下面</span><br><span class="hljs-comment">#注意-后面有一个空格</span><br>categories:<br>   - [123]   <br>   - [456]<br>   - [123, 789]<br></code></pre></td></tr></table></figure><h3 id="文章标签"><a href="#文章标签" class="headerlink" title="文章标签"></a>文章标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#两种不同的写法</span><br>tags:<br>  - 123<br>  - 456<br>tags: [123, 456]<br></code></pre></td></tr></table></figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">excerpt: 这里写简介内容<br></code></pre></td></tr></table></figure><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><h3 id="有时在”hexo-d”后会出现error的提示"><a href="#有时在”hexo-d”后会出现error的提示" class="headerlink" title="有时在”hexo d”后会出现error的提示"></a>有时在”hexo d”后会出现error的提示</h3><p>可以依次执行下面三条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure><h3 id="一段时间后突然hexo命令失效"><a href="#一段时间后突然hexo命令失效" class="headerlink" title="一段时间后突然hexo命令失效"></a>一段时间后突然hexo命令失效</h3><p>之前看的教程里环境变量的配置是错误的，也不知道当时是怎么运行的，这里再简单重新记录一下<br>之前的：D:*******\NODE_JS\node_global\node_modules\hexo-cli\node_modules.bin<br>现在的：D:*******\NODE_JS\node_global\node_modules\hexo-cli\bin<br>后者是正确的</p>]]></content>
    
    
    <categories>
      
      <category>各类教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
